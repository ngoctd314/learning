# Indexing strategies for high performance

Creating the correct indexes and using them properly is essential to good query performance.

There are many ways to choose and use indexes effectively, because there are many special-case optimizations and specialized behaviors. Determining what to use when and evaluating the performance implications of your choices are skills you'll learn over time.

## Isolating the Column

We commonly see queries that defeat indexes or prevent MySQL from using the available indexes. MySQL generally can't use indexes on columns unless the columns are isolated in the query. "Isolating" the column means it should not be part of an expression or be inside a function in the query.

For example, there's a query that can't use the index on actor_id

```sql
SELECT * FROM people WHERE CONCAT(last_name, '') = 'last_name-0-0';
+---------------+----------------+------------+--------+
| last_name     | first_name     | dob        | gender |
+---------------+----------------+------------+--------+
| last_name-0-0 | first_name-0-0 | 2012-09-01 | m      |
+---------------+----------------+------------+--------+
1 row in set
Time: 1.599s

SELECT * FROM people WHERE last_name = 'last_name-0-0';
+---------------+----------------+------------+--------+
| last_name     | first_name     | dob        | gender |
+---------------+----------------+------------+--------+
| last_name-0-0 | first_name-0-0 | 2012-09-01 | m      |
+---------------+----------------+------------+--------+
1 row in set
Time: 0.003s
```

```sql
SELECT actor_id FROM tbl WHERE actor_id + 1 = 5;
```

A human can easily see that the WHERE clause is equivalent to actor_id = 4, but MySQL can't solved the equation for actor_id. It's up to you to do this. It's up to you to do this. You should get in the habit of simplifying your `WHERE` criteria, so the indexed column is alone on one side of the comparison operator.

Here's another example of a common mistake

```sql
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

## Prefix indexes and index selectivity

Sometimes you need to index very long character columns, which makes your indexes large and slow. One strategy is to simulate a hash index, as we showed earlier in this chapter. But sometimes that isn't good enough. What can you do?

You can often save space and get good performance by indexing the first few characters instead of the whole value. This makes your indexes use less space, but it also makes them less selective.  Index selectivity is the ratio of the number of distinct indexed values (the cardinality) to the total number of rows in the table (#T), and ranges from 1/#T to 1. A highly selective index is good because it lets MySQL filter out more rows when it looks for matches. A unique index has a selective of 1, which is as good as it gets.

A prefix of the column if often selective enough to give good performance. If you're indexing BLOB or TEXT columns, or very long VARCHAR columns, you must define prefix indexes, because MySQL disallows indexing their full length.

The trick is to choose a prefix that's long enough to give good selectivity, but short enough to save space. The prefix should be long enough to make the index nearly as useful as it would be if you'd indexed the whole column. In other words, you'd like the prefix's cardinality to be close to the full column's cardinality.

To determine a good prefix length, find the most frequent values and compare that list to a list of most frequent prefixes.

TODO: read more detail

## Multicolumn Indexes

Multicolumn indexes are often very poorly understood. Common mistakes are to index many or all of the columns separately, or to index columns in the wrong order.

We'll discuss column order in the next section. The first mistake, indexing many column separately, has a distinctive signature in SHOW CREATE TABLE:

```sql
CREATE TABLE t (
    c1 int,
    c2 int,
    c3 int,
    KEY(c1),
    KEY(c2),
    KEY(c3)
);
```

This strategy of indexing often results when people give vague but authoritative sounding advice such as "create indexes columns that appear in the WHERE clause." This advice is very wrong. It will result in one-star indexes at best. These indexes can be many orders of magnitude slower than truly optimal indexes. Sometimes when you can't design a three-star index, it's much better to ignore the WHERE clause and pay attention to optimal row order or create a covering index instead.

Individual indexes on lots of columns won't help MySQL improve performance for most queries. MySQL 5.0 and newer can cope a little with such poorly indexes tables by using a strategy known as index merge, which permits a query to make limited use of multiples indexes from a single table to locate desired rows. Eariler versions of MySQL could use only a single index, so when no single index was good enough to help, MySQL often chose a table scan. For example, the film_actor table has an index on film_id and an index on actor_id, but neither is a good choice for both WHERE conditions in this query:

```sql
SELECT film_id, actor_id FROM film_actor
WHERE actor_id = 1 OR film_id = 1;
```

In older MySQL versions, that query would produce a table scan unless you wrote it as the UNION of two queries:

```sql
SELECT film_id, actor_id FROM film_actor WHERE actor_id = 1
UNION ALL
SELECT film_id, actor_id FROM film_actor WHERE film_id = 1
AND actor_id <> 1;
```

In MySQL 5.0 and newer, however, the query can use both indexes, scanning them simultaneously and merging the results. There are three variations on the algorithm: union for OR conditions, intersection for AND conditions, and unions of intersections for combinations of the two. 

```sql
CREATE TABLE film_actor (
    film_id int not null AUTO_INCREMENT,
    actor_id int,
    PRIMARY(film_id),
    KEY idx_actor_id (actor_id)
);
```

```sql
EXPLAIN SELECT film_id, actor_id FROM film_actor WHERE film_id = 1 OR actor_id = 1;
+----+-------------+------------+------------+-------+----------------------+--------------+---------+--------+------+----------+--------------------------+
| id | select_type | table      | partitions | type  | possible_keys        | key          | key_len | ref    | rows | filtered | Extra                    |
+----+-------------+------------+------------+-------+----------------------+--------------+---------+--------+------+----------+--------------------------+
| 1  | SIMPLE      | film_actor | <null>     | index | PRIMARY,idx_actor_id | idx_actor_id | 5       | <null> | 5    | 36.0     | Using where; Using index |
+----+-------------+------------+------------+-------+----------------------+--------------+---------+--------+------+----------+--------------------------+
```

The index merge strategy sometimes works very well, but it's more common for it to actually be an indication of a poorly indexed table:

- When the server intersects indexes (usually for AND conditions), it usually means that you need a single index with all the relevant columns, not multiple indexes that have to be combined.
- When the server unions indexes (usually for OR conditions), sometimes the algorithm's buffering, sorting, and merging operations use lots of CPU and memory resources. This is especially true if not all the indexes are very selective, so the scans return lots of rows to the merge operation.
- Recall that the optimizer doesn't account for this cost - it optimizes just the number of random page reads. This can make it "underprice" the query, which might in fact run more slowly than a plain table scan. The intensive memory and CPU usage also tends to impact concurrent queries, but you won't see this effect when you run
