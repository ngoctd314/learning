# Indexing Basics

An index contains values from one or more columns in a table. If you index more than one column, the column order is very important, because MySQL can only search efficiently on a leftmost prefix of the index. Creating an index on two columns is not the same as creating two separate single-column indexes.

## Types of indexes

Indexes are implemented in the storage engine layer, not the server layer. Thus, they are not standardized: indexing works slightly differently in each engine, and not all engines support all types of indexes. Even when multiple engines support the same index type, they might implement it differently under the hood.

### B-Tree indexes

Storage engines use B-Tree indexes in various ways, which can affect performance. For instance, MyISAM uses a prefix compression technique that makes indexes smaller, but InnoDB leaves values uncompressed in its indexes. Many storage engine actually use a B+ Tree index, in which each leaf node contains a link to the next for fast range traversals through nodes.

A B-Tree index speeds up data access because the storage engine doesn't have to scan the whole table to find the desired data. Instead, it starts at the root node. The slots in the root hold pointers to child nodes, and the storage engine follows these pointers. It finds the right pointer by looking at the values in the node pages, which define the upper and lower bounds of the values in the child nodes. Eventually, the storage engine either determines that the desired value doesn't exist or successfully reaches a leaf page.

B-Trees store the indexed columns in order, they're useful for seaching for ranges of data.

```sql
CREATE TABLE people (
    last_name VARCHAR(50) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    dob DATE NOT NULL,
    gender ENUM('m', 'f') NOT NULL,
    key (last_name, first_name, dob)
)
```

Notice that the index sorts the values according to the order of the columns given in the index in the CREATE TABLE statement. Look at the last two entries: there are two people with the same name but differnt birth dates, and they're sorted by birth date.

Types of queries that can use a B-Tree index. B-Tree indexes work well for lookups by the full key value, a key range, or a key prefix. They are useful only if the lookup uses a leftmost prefix of the index.

- Match the full value
  A match on the full key value specifies values for all columns in the index.

- Match a leftmost prefix
  This index can help you find all people with the last name Allen. This uses only the first column in the index.

- Match a column prefix
  You can match on the first part of a column's value. This index can help you find all people whose last names begin with J. This uses only the first column in the index.

- Match a range of values
  This index can help you find people whose last names are between Allen and Barymore. This also uses only the first column.

- Match one part exactly and match a range on another part
  This index can help you find everyone whose last name is Allen and whose first name starts with the letter K. This is an exact match on last_name and a range query on first_name.

- Index-only queries
  B-Tree indexes can normally support index-only queries, which are queries that access only the index, not the row storage.

Because the tree's nodes are sorted, they can be used for both lookups (finding values) and ORDERED BY queries. In general, if a B-Tree can help you find a row in a particular way, it can help you sort rows by the same criteria.

### Some limitations of B-Tree indexes:

- They are not useful if the lookup does not start from the leftmost side of the indexed columns.

```go
// this index (first_name, last_name, dob) won't help you find all people named Bill or all people born on a certain date
db.Select(&rs, "SELECT * FROM people WHERE last_name = ? OR dob = ?", "name", "2006-01-01")

// use can't use index to find people whose last name ends with a particular letter
db.Select(&rs, "SELECT * FROM people WHERE last_name like ?", "%1000")
```

- You can't skip columns in the index. That is you won't be able to find all people whose last name is Smith and who were born on a particular date. If you don't specify a value for the first_name column, MySQL can use only the first column of the index.

```go
// only use the first column of the index: last_name
db.SELECT(&rs, "SELECT * FROM people WHERE last_name = ? AND dob = ?", "name", "2006-01-01")
```

- The storage engine can't optimize access with any columns to the right of the first range condition. For example, if your query is WHERE last_name="Smith" AND first_name LIKE 'J%' AND dob='1976-12-23', the index access will use only the first two columns in the index, because the LIKE is a range condition. For a column that has a limited number of values, you can often work around this by specifying equality conditions instead of range conditions.

```go
// because the LIKE is a range condition, index access will use only the first two columns
db.SELECT(&rs, "SELECT * FROM people WHERE last_name = ? AND first_name LIKE ? AND dob = ?", "Smith", "J%", "2006-01-01")
```

Column order is extremely important: these limitations are all related to column ordering. For optimal performance, you might need to create indexes with the same columns in different orders to satisfy your queries.

### Hash indexes

Useful only for exact lookups that use every column in the index. Storage engine computes a hash code of the indexed columns, which is small value that will probably differ from the hash codes computed for other rows with different key values. It stores the hash codes in the index and stores a pointer to each row in a hash table.

In MySQL, only the Memory storage engine supports explicit hash indexes. They are the default index type for Memory tables, though Memory tables can have B-Tree indexes too. The Memory engine supports nonunique hash indexes, which is usually in the database world. If multiple values have the same hash code, the index will store their row pointers in the same hash code, the index will store their row pointers in the same hash table entry, using a linked list.

```sql
CREATE TABLE testhash(
    fname VARCHAR(50),
    lname VARCHAR(50),
    KEY USING HASH(fname)
) ENGINE=MEMORY;
```

Now suppose the index uses an imaginary hash function call f(), which returns the following values

```go
f("Arjen") = 2323
f("Baron") = 7437
f("Peter") = 8784
```

The index's data structure will look like this:

| Slot | Value            |
| ---- | ---------------- |
| 2323 | Pointer to row 1 |
| 2458 | Pointer to row 4 |
| 7437 | Pointer to row 2 |
| 8784 | Pointer to row 3 |

Because the indexes themselves store only short hash values, hash indexes are very compact. As a result, lookups are usually lightning fast. However, hash indexes have some limitations:

**Hash indexes have some limitations**

- Because the index contains only hash codes and row pointers rather than the values themselves, MySQL can't use the values in the index to avoid reading the rows.
- MySQL can't use hash indexes for sorting because they don't store rows in sorted order.
- Hash indexes don't support partial key matching, because they compute the hash from the entire indexed value. That is if you have an index on (A,B) and your query's WHERE clause refers only to A, the index won't help.
- Hash indexes support only equality comparisons that use the =, IN() and <=> operators (note that <> and <=> are not the same operator). They can't speed up range queries, such as WHERE price > 100.
- Accessing data in a hash index is very quickly, unless there are many collisions. When there are collisions, the storage engine must follow each row pointer in the linked list and compare their values to the lookup value to find the right row(s).
- Some index maintenance operations can be slow if there are many hash collisions.

The InnoDB storage engine hash a special feature called adaptive hash indexes. When InnoDB notices that some index values are being accessed very frequently, it builds a hash index for them in memory on top of B-Tree indexes. This gives its B-Tree process is completely automatic, and you can' control or configure it.

**Building your hash indexes**
If your storage engine doesn't support hash indexes, you can emulate them yourself in a manner similar to that InnoDB uses. This will give you access to some of the desirable properties of hash indexes, such as a very small index size for very long keys.

The idea is simple: create a pseudohash index on top of a standard B-Tree index. It will not be exactly the same thing as a real hash index, because it will still use the B-Tree index for lookups. However, it will use the key's hash values for lookups, instead of the keys themselves. All you need to do is specify the hash function manually in the query's WHERE clause.

An example of when this approach works well is for URL lookups. URLs generally cause B-Tree indexs to become huge, because they're very long.

```sql
SELECT id FROM url WHERE url="http://www.mysql.com"
```

But if you remove the index on the url column and add an indexed url_crc column to the table, you can use a query like this:

```sql
SELECT id FROM url WHERE url="http://www.mysq.com"
    AND url_crc=CRC32("http://ww.mysql.com")
```

This works well because MySQL query optimizer notices there's a small, highly selective index on the url_crc column and does an index lookup for entries with that value. Even if several rows have the same url_crc value, it's very easy to find these rows with a fast integer comparision and the examine the to find that matches the full URL exactly. The alternatively is to index the full URL as a string, what is much slower.

One drawback to this approach is the ned to maintain the hash values. You can do this manually or, in MySQL 5.0 and newer, you can use triggers.

```sql
CREATE TABLE pseudohash (
    id int unsigned NOT NULL auto_increment,
    url VARCHAR(255) NOT NULL,
    url_crc INT unsigned NOT NULL DEFAULT 0,
    PRIMARY KEY(id)
);
```

```sql
DELIMITER //

CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN
SET NEW.url_crc=crc32(NEW.url);
END;

//
CREATE TRIGGER pseudohash_crc_udp BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN
SET NEW.url_crc=crc32(NEW.url);
END;

DELIMITER;
```

If you use this approach, you should not use SHA1() or MD5() hash functions. These return very long strings, which waste a lot of space and result in slower comparisons. They are cryptographically strong functions designed to virtually eliminate collisions. Simple hash functions can offer acceptable collisions rates with better performance

If your table has many rows and CRC32() gives you too many collisions, implement your own 64-bit hash function. Make sure you use a function that returns an integer, not a string. One way to implement a 64-bit hash function is to use just part of the value returned by MD5(). This is probably less efficient that writing your own routine as a user-defined function.

**Handling hash collisions**

```sql
SELECT id FROM url WHERE url_crc=CRC32("http://www.mysql.com") AND url="http://www.mysql.com";
```

The query will not work correctly, because if another URL has the same CRC32() value, the query will return both rows:

```sql
SELECT id FROM url WHERE url_crc=CRC32("http://www.mysql.com")
```

```sql
SELECT word, crc FROM words WHERE crc = CRC32("gnu")
```

| word    | crc        |
| ------- | ---------- |
| codding | 1774765869 |
| gnu     | 1774765869 |

The correct query is as follow

```sql
SELECT word, crc FROM words WHERE crc = CRC32('gnu') AND word = 'gnu';
```

| word | crc        |
| ---- | ---------- |
| gnu  | 1774765869 |

To avoid problems with collisions, you must specify both conditions in the WHERE clause. If collisions aren't a problem - for example, because you're doing statistical queries and you dont need exact results - you can simplify, and gain some efficiency, by using only the CRC32() value in the WHERE clause.

### Spatial (R-Tree) indexes

### Full-text indexes

FULLTEXT is a special type of index that finds keywords in the text instead of comparing values directly to the values in the index. Full-text searching is completely different from other types of matching. It is much more analogous to what a search engine does that to simple WHERE parameter matching.

Having a full-text index on a column does not eliminate that value of a B-Tree index on the same column.. Full-text indexes are for MATCH AGAINST operations, not ordinary WHERE clause operations.

### Other types of index

### Benefits of Indexes

Indexes enable the server to navigate quickly to a desired position in the table, but that's not all they're good for. As you've probably gathered by now, indexes have several additional benefits, based on the properties of the data structures used to create them.

B-Tree indexes, which are the most common type you'll use, function by storing the data in sorted order, and MySQL can exploit that for queries with clauses such as ORDER BY and GROUP BY. Because the data is presorted, a B-Tree index also stores related values close together. Finally, the index actually stores a copy of the values, so some queries can be satisfied from the index alone.

1. Indexes reduce the amount of data the server has to examine
2. Indexes help the server avoid sorting and temporary tables
3. Indexes turn random I/O into sequential I/O

**Is an Index the Best Solution**

An index isn't always the right tool. For very small tables, it is often more effective to simply read all the rows in the table. For medium to large tables, indexes can be very effective. For enormous tables, the overhead of indexing, as well as the work required to actually use the indexes, can start to add up. In such cases you might need to choose a technique that identifies groups of rows that are interesting to the query, instead of individual rows. You can use partitioning for this purpose.

## Indexing Strategies for High Performance

### Isolation the column

We commonly see queries that defeat indexes or prevent MySQL from using the available indexes. MySQL generally can't use indexes on columns unless that columns are isolated in the query. "Isolating" the column means it should not be part of an expression or be inside a function in the query.

For example, here's a query that can't use the index on actor_id

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

WHERE clause is equivalent to actor_id = 4, but MySQL can't solve the equation for actor_id. So the indexed column is alone on one side of the comparison operator.

```sql
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### Prefix Indexes and Index Selectivity

Sometimes you need to index very long character columns, which makes indexes large and slow. One strategy is to simulate a hash index, as we shoed earlier in this chapter. But sometimes that isn't good enough. What you can do?

You can often save space and get good performance by indexing the first few characters instead of the whose value. This makes your indexes use less space, but it also makes them less selective.A highly selective index is good because it lets MySQL filter out more rows when it looks for matches. A unique index has selectivity of 1, which is as good as it gets.

A prefix of the column is often selective enough to give good performance. If you're indexing BLOG or TEXT columns, or very long VARCHAR columns, you must define prefix indexes, because MySQL disallows indexing their full length.

The trick is to choose a prefix that's long enough to give good selectivity, but short enough to save space. The prefix should be long enough to make the index nearly as useful as it would be if you'd indexed the whole column.

To determine a good prefix length, find the most frequent values and compare that list to a list of the most frequent prefixes.

```sql
CREATE TABLE city_demo (
    city VARCHAR(50) NOT NULL
)
```
