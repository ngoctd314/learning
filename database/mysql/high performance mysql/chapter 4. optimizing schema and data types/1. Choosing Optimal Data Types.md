# Choosing Optimal Data Types

**Smaller is usually better.** In general, try to use the smallest data type that can correctly store and represent your data. Smaller data types are usually faster, because they use less space on disk, in memory, and in the CPU cache. They also generally require fewer CPU cycles to process.

Make sure you don't underestimate the change of values you need to store, though because increasing the data type range in multiple places in your schema can be a painful and time-consuming operation. If you're in doubt as to which is the best data type to use, choose the smallest one that you don't think you'll exceed. (If the system is not very busy or doesn't store much data, or if you're at an early phase in the desing process, you can change it easily later.)

**Simple is good.** Fewer CPU cycles are typically required to process operations on simpler data types. For example, integers are cheaper to compare than characters, because character sets and collations (sorting rules) make character comparisons, complicated. Here are two examples; you should store dates and times in MySQL's builtin types instead of as strings, and you should use integers for IP addresses.

**Avoid NULL if possible.** A lot of tables include nullable columns even when the application does not need to store NULL (the absence of a value), merely because it's the default. It's usually best to specify columns as NOT NULL unless you intend to store NULL in them.

It's harder for MySQL to optimize queries that refer to nullable columns, because they make indexes, index statistics, and value comparisons more complicated. A nullable column uses more storage space and requires special processing inside MySQL.

The performance improvement from changing NULL columns to NOT NULL is usually small, so don't make it a priority to find and change them on an existing schema unless you know they are causing problems. However, if you've planing to index columns, avoid making them nullable if possible.

InnoDB stores NULL with a single bit, so it can be pretty space-efficient for sparsely populated data. This doesn't apply to MyIsAM.

MySQL supports many aliases for compatibility, such as INTEGER, BOOL, and NUMERIC. These as only aliases. They can be confusing, but they don't affect performance. If you create a table with an aliased data type and then examine SHOW CREATE TABLE, you'll see that MySQL reports the base type, not the aliased you used.

## Whole Numbers

There are two kinds of number: whole numbers and real numbers (numbers with a factional part). If you're storing whole numbers, use one of the integer types: TINYINT, SMALLINT, MEDIUMINT, INT or BIGINT. These require 8, 16, 24, 32 and 64 bits of storage space, respectively. They can store values from -2^(N-1) to 2^(N-1) - 1, where N is the number of bits of storage space they use.

Integer types can optionally have the UNSIGNED attribute, which disallows negative values and approximately doubles the upper limit of positive values you can store. For example, a TINYINT UNSIGNED can store values ranging from 0 to 255 instead of from -128 to 127.

Signed and unsigned types use the same amount of storage space and have the same performance, so use whatever's best for your data range.

Your choice determines how MySQL stores the data, in memory and on disk. However, integer computations generally use 64-bit BIGINT integers even on 32-bit architectures. (The exceptions are some aggregate functions, which use DECIMAL or DOUBLE to perform computations.)

MySQL lets you specify a "width" for integer types, such as INT(11). This is meaningless for most applications: it does not restrict the legal range of values, but simple specifies the number of characters MySQL's interactive tools (such as the command-line client) will reserve for display purposes. For storage and computation purposes, INT(1) is identical to INT(20).

## Real Number

Real numbers are numbers that have a fractional part. However, they aren't just for fractional numbers; you can also use DECIMAL to store integers that are so large they don't fit in BIGINT.

The FLOAT and DOUBLE types support approximate caculations with standard floating point math. If you need to know exactly floating point results are caculated, you will need to research your platform's floating-point.

A DECIMAL number in MySQL 5.0 and newer can have up to 65 digits. Earlier MySQL versions had a limit of 254 digits and stored the values as unpacked strings (one byte per digit). However, these versions of MySQL couldn't actually use such large numbers in computations, because DECIMAL was just a storage format; DECIMAL numbers were converted to DOUBLEs for computational purposes.

Floating-point typically use less space than DECIMAL to store the same range of values. A FLOAT column uses four bytes of storage. DOUBLE consumes eight bytes and has greater precision and a large of values than FLOAT. As with integers, you're choosing only the storage type; MySQL uses DOUBLE for its internal caculations on floating-point types.

Because of the addition space requirements and computational cost, you should use DECIMAL only when you need exact results from fractional numbers - for example, when storing financial data. But in some high-volume cases it actually makes sense to use a BIGINT instead, and store the data as some multiple of the smallest fraction of currency you need to handle.

## String types

TODO
### VARCHAR and CHAR types

The two major string types are VARCHAR and CHAR. It's hard to explain exactly how these values are stored on disk and in-memory, because the implements are storage engine-dependent. We assume you are using InnoDB and/or MyIsAM.

#### VARCHAR

VARCHAR stores variable-length character strings and is the most common string data type. It can require less storage space than fixed-length types, because it uses only as much space as it needs. The exception is a MyISAM table created with ROW_FORMAT=FIXED, which uses a fixed amount of space on disk for each row and can thus waste space.

VARCHAR uses 1 or 2 extra bytes to record the value's length: 1 byte if that column's maximum length is 255 byes or less, and 2 bytes if it's more. Assuming the latin1 character set, a VARCHAR(10) will use up to 11 bytes or storage space. A VARCHAR(1000) can use up to 1002 bytes, because it needs 2 bytes to store length information.

VARCHAR helps performance because it saves space. However, because the rows are variable-length, they can grow when you update them, which can cause extra work. If a row grows and no longer fits its original location, the behavior is storage engine-dependent. For example, MyISAM may fragment the row, and InnoDB may need to split the page to fit the row into it. Other storage engines may never update data in-place at all.

It's usually worth using VARCHAR when the maximum column length is much larger than the average length; when updates to the field are rare, so fragmentation is not a problem; and when you're using a complex character set such as UTF-8, where each character uses a variable number of bytes of storage.

In version 5.0 and newer, MySQL preserves trailing spaces when you store and retrieve values. In version 4.1 and older, MySQL strips trailing spaces. It's trickier with InnoDB, which can store long VARCHAR values as BLOBs. 

```sql
-> insert into datatype (name) values ("trailing    ");
Query OK, 1 row affected
Time: 0.011s
-> select * from datatype;
+------------+
| name       |
+------------+
| trailing   |
+------------+
1 row in set
Time: 0.016s
```

#### CHAR

CHAR is fixed-length: MySQL always allocates enough space for the specified number fo characters. When storing a CHAR value, MySQL removes any trailing spaces. (This was also true of VARCHAR in MySQL 4.1 and older versions - CHAR and VARCHAR were logically identical and differed only in storage format). Values are padded with spaces as needed for comparisons.

```sql
-> insert into datatype (name, gender) values ('admin', 'male   ');
Query OK, 1 row affected
Time: 0.010s

-> select * from datatype;
+-------+--------+
| name  | gender |
+-------+--------+
| admin | male   |
+-------+--------+
1 row in set

-> select concat("'", gender, "'") as gender from datatype;
+--------+
| gender |
+--------+
| 'male' |
+--------+
1 row in set
```

CHAR is useful if you want to store very short strings, or if all the values are nearly the same length. For example, CHAR is a good choice for MD5 values for user pass-words, which are always the same length. CHAR is also better than VARCHAR for data that's changed frequently, because a fixed-length row is not prone to fragmentation. For very short columns, CHAR is also more efficient than VARCHAR, a CHAR(1) designed to hold only Y and N values will use only one byte in a single-byte character set, but a VARCHAR would use two bytes because of the length byte.

**Note** Remember that the length is specified in characters, not bytes. A multibyte character set can require more than one byte to store each character.

How data is stored up to the storage engines, and not all storage engines handle fixed length and variable-length data the same way. The Memory storage engine uses fixed size rows, so it has to allocate the maximum space for each value even when it's a variable-length field. However, the padding and trimming is consistent across storage engines, because the MySQL server itself handles that.

The sibling types for CHAR and VARCHAR are BINARY and VARBINARY, which store binary strings. Binary strings are very similar to conventional strings, but they store bytes instead of characters. Padding is also different: MySQL pads BINARY values with \O (the zero byte) instead of spaces and doesn't strip the pad value on retrieval.

These types are useful when you need to store binary data and want MySQL to compare the values as bytes instead of characters. The advantage of byte-wise comparisons is more than just a matter of case insensitivity. MySQL literally compares BINARY strings one byte at a time, according to the numeric value of each byte. As a result, binary comparisons can be much simpler than character comparisons, so they are faster.

**Generosity Can Be Unwise**

Storing the value 'hello' requires the same amount of space in a VARCHAR(5) and a VARCHAR(200) column. Is there any advantage to using the shorter column?

As it turns out, there is a big advantage. The larger column can use much more memory, because MySQL often allocates fixed-size chunks of memory to hold values internally. This is especially bad for sorting or operations that use in-memory temporary tables. The same thing happens with filesorts that use on disk temporary tables.

The best strategy is to allocate only as much space as you really need.

#### BLOB and TEXT types

BLOG and TEXT are string date types designed to store large amounts of data as either binary or character strings, respectively.

In fact, they are each families of data types: the character types are TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT and LONGTEXT and the binary types are TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, and LONGBLOB. BLOB is a synonym for SMALLBLOB, and TEXT is synonym for SMALLTEXT.

The only difference between the BLOB and TEXT families is that BLOB types store binary data with no collation or character set, but TEXT types have a character set and collation.

MySQL sorts BLOB and TEXT columns differently from other types: instead of sorting the full length of the string, it sorts only the first max_sort_length bytes of such columns. If you need to sort by only the first few characters, you can either decrease the max_sort_length server variable or use ORDER BY SUBSTRING(column, length).

**On-Disk Temporary Tables and Sort Files**

Because the Memory storage engine doesn't support the BLOB and TEXT types, queries that use BLOB or TEXT columns and need an implicit temporary table will have to use on-disk MyISAM temporary tables, even for only a few rows. (Percona Server's Memory storage engine supports the BLOB and TEXT types, but at the time of writing, it doesn't yet prevent on-disk tables from being used.)

This can result in a serious performance overhead. Even if you configure MySQL to store temporary table on a RAM disk, many expensive operating system calls will be required.

The best solution is to avoid using the BLOB and TEXT types unless you really need them. If you can't avoid them, you may be able to use the SUBSTRING(column, length) trick everywhere a BLOB column is mentioned (including in the ORDER BY clause) to convert the values to character strings, which will permit in-memory temporary tables. Just be sure that you're using a short enough substring that the temporary table doesn't grow larger than max_heap_table_size or tmp_table_size, or MySQL will convert the table to an on-disk MyISAM table.

The worst-case length allocation also applies to sorting of values, so this trick can help with both kinds of problems: creating large temporary tables and sort files, and creating them on disk.

Suppose you have a table with 10 million rows, which uses a couple of gigabytes on disk. It has a VARCHAR(1000) column with the utf8 character set. This can use up to 3 bytes per character, for a worst case size of 3000 bytes. If you mention 30 GB of temporary space just for the sort files!

#### Using ENUM instead of a string type

Sometimes you can use an ENUM column instead of conventional string types. An ENUM column can store a predefined set of distinct string values. MySQL stores them very compactly, packed into one or two bytes depending on the number of values in the list. It stores each value internally as an integer representing its position in the field definition list, and it keeps the "lookup table" that defines the number-to-string corresponding in the table's .frm file.

```sql
-> create table enum_test(
    e ENUM('fish', 'apple', 'dog') NOT NULL default 'fish'
    );
Query OK, 0 rows affected
Time: 0.029s
-> insert into enum_test(e) values ('fish'), ('dog'), ('apple');
Query OK, 3 rows affected
Time: 0.011s
```

The three rows actually store integers, not strings. You can see the dual nature of the values by retrieving them in a numeric context:

```sql
-> select e + 0 from enum_test;
+-------+
| e + 0 |
+-------+
| 1.0   |
| 3.0   |
| 2.0   |
+-------+
3 rows in set
Time: 0.009s
```

Another surprise is that an ENUM field sorts by the internal integer values, not by the strings themselves

```sql
-> select e from enum_test order by e;
+-------+
| e     |
+-------+
| fish  |
| apple |
| dog   |
+-------+
3 rows in set
Time: 0.004s
```

The biggest downside of ENUM is that the list of strings is fixed, and adding or removing strings requires the use of ALTER TABLE. Thus, it might not be a good idea to use ENUM as a string data type when the list of allowed string values is likely to change arbitrarily in the future, unless it's acceptable to add them at the end of the list, which can be done without a full rebuild of the table in MySQL 5.1.

Because the MySQL stores each value as an integer and has to do a lookup to convert it to its string representation. This is usually offset by their smaller size, but not always. In particular, it can be slower to join a CHAR or VARCHAR column to an ENUM column than to another CHAR and VARCHAR column.

#### Date and Time Types

MySQL have DATETIME and TIMESTAMP.

**DATETIME**

This type can hold a large range of values, from the year 1001 to the year 9999, with a precision of one second. It stores the date and time packed into an integer in YYYYMMDDHHMMSS format, independent of timezone. This uses eight bytes for storage space.

**TIMESTAMP**

TIMESTAMP stores the number of seconds elapsed since midnight, January 1, 1970. TIMESTAMP uses only four bytes of storage, so it has a much smaller range than DATETIME: from the year 1970 to partway through the year 2038. MySQL provides the FROM_UNIXTIME() and UNIX_TIMESTAMP() functions to convert a Unix timestamp to a date, and vice versa.

The value of TIMESTAMP displays also depends on the time zone. The MySQL server, os, and client connections all have time zone settings.

TIMESTAMP also has special properties that DATETIME doesn't have. By default, MySQL will set the first TIMESTAMP column to the current time when you insert a row without specifying a value for the column. MySQL also updates the first TIMESTAMP column's value by default when you update the row, unless you assign a value explicitly in the UPDATE statement. TIMESTAMP columns are NOT NULL by default, which is different from every other data type.

The rules from TIMESTAMP behavior are complex and have changed in various MySQL versions, so you should verify that you are getting the behavior you want. It's usually a good idea to examine the output of SHOW CREATE TABLE after making changes to TIMESTAMP columns.

Special behavior aside, in general if you can use TIMESTAMP you should, because it is more space-efficient than DATETIME. Sometimes people store Unix timestamps as integer values, but this usually doesn't gain you anything. The integer format is often less convenient to deal with, so we do not recommend doing this.

What if you need to store a date and time value with subsecond resolution? MySQL currently does not have an appropriate data type for this, but you can use your own storage format: you can use the BIGINT data type and store the value as a timestamp in microseconds, or you can use a DOUBLE and store fractional part of the second after the decimal point. Both approaches will work well.  

#### Bit-Packed Data Types

#### Choosing Identifiers

Choosing a good data type for an identifier column is very important. You're more likely to compare these columns to other values (for example, in joins) and to use them for lookups than other columns. You're likely to use them in other tables as foreign keys, so when you choose a data type for an identifier column, you're probably choosing the type in related tables as well.

When choosing a type for an identifier column, you need to consider not only the storage type, but also how MySQL performs computations and comparisons on that type. For example, MySQL stores ENUM and SET types internally as integers but converts them to strings when doing comparisons in a string context.

Once you choose a type, make sure you use the same type in all related table. The types should match exactly, including properties such as UNSIGNED. Mixing different data types can cause performance problems, and even if it doesn't, implicit type conversions during comparisons can create hard-to-find errors. These may even crop up much later, after you've forgotten than you're comparing different data types.

**INTEGER types**

Integers are usually the best choice for identifiers, because they're fast and they work with AUTO_INCREMENT.

**String types**

Avoid string types for identifiers if possible, because they take up a lot of space and are generally slower than integer types.

You should also be very careful with completely "random" strings, such as those produced by MD5(), SHA1(), or UUID(). Each new value you generate with them will be distributed in arbitrary ways over a large space, which can slow INSERT and some types of SELECT queries:

- They slow **INSERT** queries because the inserted value has to go in a random location in indexes. This causes page splits, random disk accesses, adn clustered index flagmentation for clustered storage engines.
- They slow **SELECT** queries because logically adjacent rows will be widely dispersed on disk and in memory.
- Random values cause caches to perform poorly for all types of queries because they defeat locality of reference, which is how caching works. If the entire dataset is equally "hot", there is no advantage to having any particular part of the data cached in memory, and if the working set does not fit in memory, the cache will have a lot of flushes and misses.

If you do store UUID values, you should remove the dashes or, even better, convert the UUID values to 16-byte numbers with UNHEX() and store them in a BINARY(16) column. You can retrieve the values in hexadecimal format with the HEX() function.

### Special Types of Data

Some kinds of data don't correspond directly to the available built-in types. A time-stamp with subsecond resolution is one example; we showed you some options for storing such data eailer in the chapter.

Another example is an IPv4 address. People often use VARCHAR(15) columns to store IP addresses. However, they are really unsigned 32-bit integers, not strings. The dotted-quad notation is just a way of writing it out so that humans can read it more easily. You should store IP addresses as unsigned integers. MySQL provides the INET_ATON() - internet address to number, and INET_NTOA() - internet number to address functions to convert between the two representations.
