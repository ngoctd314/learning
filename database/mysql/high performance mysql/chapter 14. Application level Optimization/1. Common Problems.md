# Common Problems

If you spend a lot of time improving MySQL's performance, it's easy to get tunnel vision and forget to focus o the user's experience. You may step back for a bit and realize that MySQL is so highly optimized that it's contributing only a tiny fraction of the response time the user sees, and it's time to focus elsewhere. This is a great insight. But what is causing problems, if not MySQL? The answer can be found most reliably and quickly by measuring, using the techniques. If you profiling is thorough and you follow a logical process, it should not be hard to find the source of your problem.

We see the same problems over and over again in applications.

- What's using the CPU, disk, network, and memory resources on each of the machines involved? Do the numbers look reasonable to you? If not, check the basics for the applications that are hogging resources. Configuration is sometimes the simplest way to solve problems. Configuration is sometimes the simplest way to solve problems. For example, if Apache runs out of memory because it creates 1000 worker processes that each need 50 MB of memory, you can configure the application to require fewer Apache workers. You can also configure the system to use less memory for each process.
- Is the application really using all the data it's getting? Fetching 1000 rows but displaying only 10 and throwing away the rest is a common mistake. However, if the application caches the other 990 rows for later use, it might be an intentional optimization.
- Is the application doing processing that ought to be done in the database, or vice versa? Two examples are fetching all rows from a table to count them and doing complex string manipulations in the database. Databases are good at counting rows and application languages are good at regular expressions. Use the best tool for the job.
- Is the application doing too many queries? ORM query interfaces that "protect programmers from having write SQL" are often to blame. The db server is designed to match data from multiple tables. Re-move the nested loops in the code and write a join instead.
- In the application doing too few queries. We know, we just said doing too many queries can be a problem. But sometimes "manual joins" and similar practices can be a good idea, because the can permit more granular and efficient caching, less locking, and sometimes even faster execution when you emulate a hash join in application code (MySQL's nested loop join method is not always efficient).
- Is the application connecting to MySQL unnecessarily? If you can get the data from the cache, don't connect.
- Is the application connecting too many times to the same MySQL instance, perhaps because different parts of the application open their own connections. It's usually a better idea to reuse the same connection throughout.
- Is the application doing a lot of garbage queries? A common example is sending a ping to see if the server is alive before sending the query itself, or selecting the desired database before each query. It might be a good idea to always connect to a specific database and use fully qualified named for tables. Preparing the connection is another common problem. The Java driver in particular does a lot of things during preparation, most of which can disable. Another common garbage query is SET NAMES UTF8, which is the wrong way to do things anyway (it does not change the client library's character set; it affects only the server). If you application uses a specific character set for most of its work, you can avoid thee need to change the character set by configuring it as the default.
- Does the applications use a connection pool? This can be both a good and a bad thing. It helps limit the number of connections, which is good when connection aren't used for many queries. However, it can have side effects, such as applications interfering with each other's transactions, temporary tables, connection-specific settings, and user-defined variables.
- Does the application use persistent connections? These can result in way too many connections to MySQL. They're generally a bad idea, except if the const of connecting is MySQL is very high because of a slow network, if the connection will be used only for one or two fast queries, or if you're connecting so frequently that you're running out of local port numbers on the client.
-  Is the application holding connections open even when it's not using them? If so particularly if it connects to many servers - it might be consuming connections that other processes need. For example, suppose you're connecting to 10 MySQL servers, but only one of them will really be doing anything at any given time. The other time nine will spend a lot of time in the Sleep state. If one server slows down, or there's a long network call, the other servers can suffer because they're out of connections. The solution is to control how the application uses connections. For example, you can batch operations to each MySQL instance in turn, and close each connection before querying the next one. If you're doing time-consuming operating, such as calls to a web service, you can even close the MySQL connection, perform the time consuming work, then reopen the MySQL connection, perform the time consuming work, then reopen the MySQL connection and continue working with the database.

Connection pools don't usually result in as many connections to the server, because they queue and share connections among processes. Persistent connections, on the other hand, are created on a per-process basis and can't be shared among processes.

Connection pools also allow more control over connection policies than shared connections. You can configure a pool to auto-extend, but the usual practice is to queue connection requests when the pool is completely busy. This makes the connection requests wait on the application server, rather than overload the MySQL server with too many connections.

There are many ways to make queries and connections faster, but the general rule is that avoiding them altogether is better than trying to speed them up.

## Web Server Issues

Apache is the most popular server software for web applications. It works well for many purposes, but when used badly it can consume a lot of resources.

## Finding the Optimal Concurrency

Every web server has an optimal concurrency - that is an optimal number of concurrent connections that will result in requests being processed as quickly as possible, without overloading your systems.