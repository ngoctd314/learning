# Limitations of the MySQL Query Optimizer

MySQL's "everything is nested-loop join" approach to query execution isn't ideal for optimizing every kind of query. Fortunately, there are only a limited number of cases where the MySQL query optimizer does a poor job, and it's usually possible to rewrite such queries more efficiently.

## Correlated Subqueries

MySQL sometimes optimizes subqueries very badly. The worst offenders are IN() sub-queries in the WHERE clause in the WHERE clause.

```sql
SELECT * FROM sakila.film
WHERE film_id IN (
    SELECT film_id FROM sakila.film_actor WHERE actor_id = 1;
)
```

It's tempting to think that MySQL will execute this query from the inside out, by finding a list of id values and substituting them into the IN() list. We said an IN() list is generally very fast, so you might expect the query to be optimized to something like this:

```sql
SELECT * FROM sakila.film
WHERE film_id
IN (...)
```

Unfortunately, exactly the opposite happens. MySQL tries to "help" the subquery by pushing a correlation into it from the outer table, which is thinks will let the subquery find rows more efficiently. It rewrites the query as follows:

```sql
SELECT * FROM sakila.film
WHERE EXISTS (
    SELECT * FROM sakila.film_actor WHERE actor_id = 1
    AND film_actor.film_id = film.film_id);
```

Now the subquery requires the film_id from the outer film table and can't be executed first. EXPLAIN shows the result as DEPENDENCT SUBQUERY (you can use EXPLAIN EXTENDED to see exactly how the query is rewritten):

```sql
EXPLAIN SELECT * FROM sakila.film ...;
+----+--------------------+------------+--------+------------------------+
| id | select_type        | table      | type   | possible_keys          |
+----+--------------------+------------+--------+------------------------+
| 1  | PRIMARY            | film       | ALL    | NULL                   |
| 2  | DEPENDENT SUBQUERY | film_actor | eq_ref | PRIMARY,idx_fk_film_id |
+----+--------------------+------------+--------+------------------------+
```

According to the EXPLAIN output, MySQL will table-scan the film table and execute the subquery for each row it finds. This won't cause a noticeable performance hit on a small tables, but if the outer table is very large, the performance will be extremely bad.

```sql
SELECT film.* FROM sakila.film
    INNER JOIN sakila.film_actor USING(film_id)
WHERE actor_id = 1;
```

Another good optimazation is to manually generate the IN() list by executing the sub-query as a separate query with GROUP_CONCAT(). Sometimes this can be faster that a JOIN. And finally, although IN() subqueries work poorly in many cases, EXISTS() or equality subqueries somtimes work much better. Here is another way to rewrite our IN() subquery example:

```sql
SELECT * FROM sakila.film
WHERE EXISTS (
    SELECT * FROM sakila.film_actor WHERE actor_id = 1
        AND film_actor.film_id = film.film_id
);
```

## When a correlated subquery is good

MySQL doesn't always optimize correlated subqueries badly. If you hear advice to always avoid them, don't listen! Instead, measure and make your own decision. 

```sql
EXPLAIN SELECT film_id, language_id from sakila.film
WHERE NOT EXISTS(
    SELECT * FROM sakila.film_actor
    WHERE film_actor.film_id = film.film_id
)
```

The standard advice for this query is to write it as a `LEFT OUTER JOIN` instead of using a subquery. In theory, MySQL's execution plan will be essentially the same either way.

```sql
EXPLAIN SELECT film.film_id, film.language_id
FROM sakila.film
    LEFT OUTER JOIN sakila.film_actor USING(film_id)
WHERE film_actor.film_id IS NULL\G
```

So, in theory, MySQL will execute the queries almost identically. In reality, measuring is the only way to tell which approach is really faster.

However, this isn't always the case. Sometimes a subquery can be faster. For example, it can work well when you just want to see rows from one table that match rows in another table. Although that sounds like it describes a join perfectly, it's not always the same thing.

```sql
SELECT film.film_id FROM sakila.film
    INNER JOIN sakila.film_actor USING(film_id);

SELECT DISTINCT film.film_id FROM sakila.film
    INNER JOIN sakila.film_actor USING(film_id);
```

### Union Limitations

MySQL sometimes can't "push down" conditions from the outside of a UNION to the inside, where they could be used to limit results or enable additional optimizations.
