# Query Execution Basics

How MySQL optimizes and executes queries.

What happens when you send MySQL a query:

1. The client sends the SQL statement to the server
2. The server checks the query cache. If there's a hit, it returns the stored result from the cache; otherwise, it passes the SQL statement to the next step
3. The server parses, preprocesses, and optimizes the SQL into a query execution plan
4. The query execution engine executes the plan by making calls to the storage engine API
5. The server sends the result to the client

## The MySQL Client/Server protocol

The protocol is half-duplex, which means that at any given time the MySQL server can be either sending or receive mesages, but not both. This protocol makes MySQL communication simple and fast, but it limits it in some ways too. For one thing, it means there's no flow control; once one side sends a message, the other side must fetch the entire message before responding. It's like a game of tossing a ball back and forth: only one side has the ball at any instant, and you can't toss the ball (send a message) unless you have it.

The client sends a query to the server as a single packet of data. This is why the max_allowed_packet configuration variable is important if you have large queries. Once the client sends the query, it doesn't have the ball anymore; it can only wait for results.

In constrast, the response from the server usually consists of many packet of data. When the server responds, the client has to receive the entire result set. It cannot simply fetch a few rows and then ask the server not to bother sending the test. If the client nees only the first new rows that are returned, it either has to waot for all of the server's packets to arrive and then discard the ones it doesn't need, or disconnect ungracefully.

Here's another way to think about this: when a client fetchs rows from the server, it thinks it's pulling them. But the truth is, the MySQL server is pushing the rows as it generates them. The client is only receiving the pushed rows; there is no way for it to tell the server to stop sending rows. The client is "drinking fromt he fire hose". 

### Query states

Each MySQL connection, or thread, has a state that shows what it is doing at any given time. There are several ways to view these states, but the easiest is to use the SHOW FULL PROCESSLIST command.

- Sleep: The thread is waiting for a new query from the client
- Query: The thread is either executing the query or sending the result back to the client
- Locked: The thread is waiting for a table lock to be granted at the server level.
- Analyzing and statistics: The thread is checking storage engine statistics and optimizing the query.
- Copying to tmp table [on disk]: The thread is processing the query and copying results to a temporary table, probably for a GROUP BY
- Sorting result: The thread is sorting a result set
- Sending data

### The Query Cache

Before even parsing a query, MySQL checks for it in the query cache, if the cache is enabled. This operation is cace-sensitive hash lookup. If the query differs from a similar query in the cache by even a single byte, it won't match, and the query processing will go to the next stage.

If MySQL does find a match in the query cache, it must check privileges before returning the cached query.

## The query optimization process

The next step turns a SQL query into an execution plan for the query execution engine. It has several substeps: parsing, preprocessing, and optimization.  Errors can be rasied at any point in the process.

### The parser and the preprocessor

To begin, MySQL's parser breaks the query into tokens and builds a "parse tree" from them. The parser uses MySQL's SQL grammar to interpret and validate the query. For instance, it ensures that the tokens in the query are valid and in the proper order, and it checks for mistakes such as quoted strings that aren't terminated.

The preprocessor then checks the resulting parse tree for additional semantics that the parser can't resolve. For example, it checks that tables and columns exist, and it resolves names and aliases to ensure that column references aren't ambiguous.

Next, the preprocessor check privileges. This is normally very fast unless your server has large numbers of privileges.

### The query optimizer

The parse tree is now valid and ready for the optimizer to turn it into a query execution plan. A query can often be executed many different ways and produce the same result. The optimizer's job is to find the best option. 

MySQL uses a cost-based optimizer, which means it tries to predict the cost of varios execution plans and choose the least expensive. The unit of cost was originally a single random 4KB data page read. You can see how expensive the optimizer estimated a query to be by running the query, then in-specing the Last_query_cost session variable: 

```sql
SELECT SQL_NO_CACHE_COUNT(*) FROM film_actors;
SHOW STATUS LIKE 'Last_query_cost';
```

The optimizer might not always choose the best plan, for many reasons:

- The statistics could be wrong.
- The cost metric is not exactly equivalent to the true cost of running the query
- MySQL's idea of 'optimal' might not match yours. You probably want the fastest execution time, but MySQL doesn't really try to make queries fast; it tries to minimize their cost, and as we've seen, determining cost is not an exact science.
- MySQL doesn't consider other queries that are running concurently, which can affect how quickly the query run. 
- MySQL doesn't always do cost-based optimization.
- ...

MySQL's query optimizer is a highly complex piece of software, and it uses many optimizations to transform the query into an execution plan. There are two basic types of optimizations, which we call static and dynamic. Static optimizations can be performed simply by inspecting the parse tree. For example, the optimizer can transform the WHERE clause into an equivalent form by applying algebraic rules. You can think of these as "compile-time optimizations"

Dynamic optimizations are based on context and depend on many factors, such as which value is in a WHERE clause or how many rows are in an index. The must be re-evaluated each time the query is executed. You can think of these as "runtime optimizations." 

Here are some types of optimizations MySQL knows how to do:

**Reordering joins**
Tables dont always have to be joined in the order you specify in the query. Determining the best join order is an important optimization.

**Converting OUTER JOINs to INNER JOINs**
An OUTER JOIN doesn't necessarily have to be executed as an OUTER JOIN. Some factors, such as the WHERE clause and table schema, can actually cause an OUTER JOIN to be equivalent to an INNER JOIN.

**Applying algebraic equivalent rules**
MySQL applies algebraic transformations to simplify and canonicalize expressions. It can also fold and reduce constants, elimicating impossible contraints and constant conditions. For example, the term (5=5 AND a > 5) will reduce to just a > 5. a<b AND b=c AND a=5 becomes b>5 AND b=c AND a=5. These rules are very useful for writing conditional queries, which we discuss later in this chapter.

**COUNT(), MIN(), and MAX() optimizations**
???

**Evaluating and reducing constant expressions**
When MySQL detects that an expression can be reduced to a constant, it will do so during optimization phase. One example is a MIN() on an index. This can even be extended to a constant lookup on a primary key or unique index. If a WHERE clause applies a constant condition to such an index, the optimizer knows MySQL can look up the value at the beginning of the query. It will then treat the value as a constant in the rest of the query. 
???

**Covering indexes**

**Subquery optimization**

**Early termination**

218
