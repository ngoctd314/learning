# Query Execution Basics

How MySQL optimizes and executes queries.

What happens when you send MySQL a query:

1. The client sends the SQL statement to the server
2. The server checks the query cache. If there's a hit, it returns the stored result from the cache; otherwise, it passes the SQL statement to the next step
3. The server parses, preprocesses, and optimizes the SQL into a query execution plan
4. The query execution engine executes the plan by making calls to the storage engine API
5. The server sends the result to the client

## The MySQL Client/Server protocol

The protocol is half-duplex, which means that at any given time the MySQL server can be either sending or receive mesages, but not both. This protocol makes MySQL communication simple and fast, but it limits it in some ways too. For one thing, it means there's no flow control; once one side sends a message, the other side must fetch the entire message before responding. It's like a game of tossing a ball back and forth: only one side has the ball at any instant, and you can't toss the ball (send a message) unless you have it.

The client sends a query to the server as a single packet of data. This is why the max_allowed_packet configuration variable is important if you have large queries. Once the client sends the query, it doesn't have the ball anymore; it can only wait for results.

![MySQL parser](../assets/mysql_parser.png)

In constrast, the response from the server usually consists of many packet of data. When the server responds, the client has to receive the entire result set. It cannot simply fetch a few rows and then ask the server not to bother sending the test. If the client needs only the first new rows that are returned, it either has to want for all of the server's packets to arrive and then discard the ones it doesn't need, or disconnect ungracefully. Neither is a good idea, which is why appropriate LIMIT clauses are so important.

Here's another way to think about this: when a client fetchs rows from the server, it thinks it's pulling them. But the truth is, the MySQL server is pushing the rows as it generates them. The client is only receiving the pushed rows; there is no way for it to tell the server to stop sending rows. The client is "drinking fromt he fire hose".    

Most libraries that connection to MySQL let you either fetch the whole result set and buffer it in memory, or fetch each row as you need it. The default behavior is generally to fetch the whole result and buffer it in memory. This is important because until all the rows have been fetched, the MySQL server will not release the locks and other resources required by the query. The query will be in the "Sending data" state. When the client library fetches results all at once, it reduces the amount of work the server needs to do: the server can finish and clean up the query as quickly as possible.

Most client libraries let you treat the result set as though you're fetching it from the server, although in fact you're just fetching it from the buffer in the library's memory. This works fine most of the time, but it's not a good idea for huge result sets that might take a long time to fetch and use a lot of memory. You can use less memory, and start working on the result sooner, if you instruct the library not to buffer the result. The downside is that the locks and other resource on the sever will remain open while your application is interacting with the library.

```php
<?php
$link = mysql_connect('localhost', 'user', 'p4assword');
$result = mysql_query('SELECT * FROM HUGE_TABLE', $link);
while ($row = mysql_fetch_array($result)) {
    // Do something with result
}
```

The code seems to indicate that you fetch rows only when you need them, in the while loop. However, the code actually fetches the entire result into a buffer with the mysql_query() function call. The while loop simple iterates through the buffer. In contrast, the following code doesn't buffer the results, because it uses mysql_unbuf fered_query() instead of mysql_query():

```php
<?php
$link = mysql_connect('localhost', 'user', 'p4assword');
$result = mysql_unbuffered_query('SELECT * FROM HUGE_TABLE', $link);
while ($row = mysql_fetch_array($result)) {
    // Do something with result
}
```

### Query states

Each MySQL connection, or thread, has a state that shows what it is doing at any given time. There are several ways to view these states, but the easiest is to use the SHOW FULL PROCESSLIST command.

- Sleep: The thread is waiting for a new query from the client
- Query: The thread is either executing the query or sending the result back to the client
- Locked: The thread is waiting for a table lock to be granted at the server level. Locks that are implemented by the storage engine, such as InnoDB's row locks, do not cause the thread to enter the Locked state.
- Analyzing and statistics: The thread is checking storage engine statistics and optimizing the query.
- Copying to tmp table [on disk]: The thread is processing the query and copying results to a temporary table, probably for a GROUP BY, for a filesort, or to satify a UNION. If the state ends with "on disk", MySQL is converting an in-memory table to an on-disk table.
- Sorting result: The thread is sorting a result set
- Sending data: This can mean several things: the thread might be sending data between stages of the query, generating the result set, or returning the result set to the client.

### The Query Cache

Before even parsing a query, MySQL checks for it in the query cache, if the cache is enabled. This operation is cace-sensitive hash lookup. If the query differs from a similar query in the cache by even a single byte, it won't match, and the query processing will go to the next stage.

If MySQL does find a match in the query cache, it must check privileges before returning the cached query. This is possible without parsing the query, because MySQL stores table infromation with the cached query. If the privileges are OK, MySQL retrieves the stored result from the query cache and sends it to the client, bypassing every other stage in query execution.

## The query optimization process

The next step turns a SQL query into an execution plan for the query execution engine. It has several substeps: parsing, preprocessing, and optimization. Errors can be rasied at any point in the process.

### The parser and the preprocessor

To begin, MySQL's parser breaks the query into tokens and builds a "parse tree" from them. The parser uses MySQL's SQL grammar to interpret and validate the query. For instance, it ensures that the tokens in the query are valid and in the proper order, and it checks for mistakes such as quoted strings that aren't terminated.

The preprocessor then checks the resulting parse tree for additional semantics that the parser can't resolve. For example, it checks that tables and columns exist, and it resolves names and aliases to ensure that column references aren't ambiguous.

Next, the preprocessor check privileges. This is normally very fast unless your server has large numbers of privileges.

### The query optimizer

The parse tree is now valid and ready for the optimizer to turn it into a query execution plan. A query can often be executed many different ways and produce the same result. The optimizer's job is to find the best option.

MySQL uses a cost-based optimizer, which means it tries to predict the cost of varios execution plans and choose the least expensive. The unit of cost was originally a single random 4KB data page read. You can see how expensive the optimizer estimated a query to be by running the query, then in-specting the Last_query_cost session variable:

```sql
SELECT SQL_NO_CACHE_COUNT(*) FROM film_actors;
SHOW STATUS LIKE 'Last_query_cost';

SHOW STATUS LIKE 'Last_query_cost';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| Last_query_cost | 47.099000 |
+-----------------+-----------+
```

The result means that the optimizer estimated it would need to do about 47 random data page reads to execute the query. The optimizer does not include the effects of any type of caching in its estimates - it assumes every read will result it a disk I/O operation.

The optimizer might not always choose the best plan, for many reasons:

- The statistics could be wrong.
- The cost metric is not exactly equivalent to the true cost of running the query, so even when the statistics are accurate, the query might be more or less expensive than MySQL's approximation.
- MySQL's idea of 'optimal' might not match yours. You probably want the fastest execution time, but MySQL doesn't really try to make queries fast; it tries to minimize their cost, and as we've seen, determining cost is not an exact science.
- MySQL doesn't consider other queries that are running concurently, which can affect how quickly the query run.
- MySQL doesn't always do cost-based optimization.
- ...

MySQL's query optimizer is a highly complex piece of software, and it uses many optimizations to transform the query into an execution plan. There are two basic types of optimizations, which we call static and dynamic. Static optimizations can be performed simply by inspecting the parse tree. For example, the optimizer can transform the WHERE clause into an equivalent form by applying algebraic rules. You can think of these as "compile-time optimizations"

Dynamic optimizations are based on context and depend on many factors, such as which value is in a WHERE clause or how many rows are in an index. The must be re-evaluated each time the query is executed. You can think of these as "runtime optimizations."

The different is important when executing prepared statements or stored procedures. MySQL can do static optimizations once, but it must re-evaluated dynamic optimizations every time it executes a query.

Here are some types of optimizations MySQL knows how to do:

**Reordering joins**
Tables dont always have to be joined in the order you specify in the query. Determining the best join order is an important optimization.

**Converting OUTER JOINs to INNER JOINs**
An OUTER JOIN doesn't necessarily have to be executed as an OUTER JOIN. Some factors, such as the WHERE clause and table schema, can actually cause an OUTER JOIN to be equivalent to an INNER JOIN.

**Applying algebraic equivalent rules**
MySQL applies algebraic transformations to simplify and canonicalize expressions. It can also fold and reduce constants, elimicating impossible contraints and constant conditions. For example, the term (5=5 AND a > 5) will reduce to just a > 5. a<b AND b=c AND a=5 becomes b>5 AND b=c AND a=5. These rules are very useful for writing conditional queries, which we discuss later in this chapter.

**COUNT(), MIN(), and MAX() optimizations**
To find the minimum value of a column that's leftmost in a B-Tree index, MySQL can just request the first row in the index. In can even do this in the query optimization stage, and treat the value as a constant for the rest of the query. Similarly, to find the maximum value in a B-Tree index, the server reads the last row. If the server uses this optimization.

Likewise, COUNT(\*) queries without a WHERE clause can often be optimized away on some storage engines (such as MyISAM, which keeps an exact count of rows in the table at all times).

**Evaluating and reducing constant expressions**
When MySQL detects that an expression can be reduced to a constant, it will do so during optimization phase. One example is a MIN() on an index. This can even be extended to a constant lookup on a primary key or unique index. If a WHERE clause applies a constant condition to such an index, the optimizer knows MySQL can look up the value at the beginning of the query. It will then treat the value as a constant in the rest of the query.
???

**Covering indexes**
MySQL can sometimes use an index to avoid reading row data, when the index contains all the columns the query needs.

**Subquery optimization**
MySQL can convert some types of subqueries into more efficient alternatives forms, reducing them to index lookups instead of separate queries.

TODO: Read again
**Early termination**
MySQL can stop processing a query (or a step in a query) as soon as it filfills the query or step. The obvious case is a LIMIT clause, but there are several other kinds of early termination. For instance, if MySQL detects an impossible condition, it can about the entire query.

```sql
EXPLAIN SELECT film.film_id FROM film WHERE film_id = -1;

+----+-----------------------------------------------------+
| id | Extra |                                             |
+----+-----------------------------------------------------+
| 1 | Impossible WHERE noticed after reading const tables  |
+----+-----------------------------------------------------+
```

This query stopped during the optimization step, but MySQL can also terminate execution early in some other cases. The server can use this optimization when the query execution engine recognizes the need to retrieve distinct values, or to stop when a value doesn't exist.

**Equality propagation**

MySQL recognizes when a query holds two columns as equal.

```sql
SELECT film.film_id
FROM sakila.film
    INNER JOIN sakila.film_actor USING(film_id)
WHERE film.film_id > 500;
```

MySQL knows that the `WHERE` clause applies not only to the film table but to the film_actor table as well, because the `USING` clause forces the two columns to match.

If you're used to another database server that can't do this, you might have been advised to "help the optimizer" by manually specifying the `WHERE` clause for both tables like this:

```sql
WHERE film.film_id > 500 AND film_actor.film_id > 500;
```

**IN() list comparisons**

In many database servers, IN() is just a synonym for multiple OR clauses, because the two are logically equivalent. Not so in MySQL, which sorts the values in the IN() list and uses a fast binary search to see whether a value is in the list. This is O(logn) in the size of the list, whereas an equivalent series of OR clauses is O(n) in the size of the list.

### Table an index statistics

The server layer, which contains the query optimizer, doesn't store statistics on data and indexes. That's a job for the storage engines, because each storage engine might keep different kinds of statistics (or keep them in a different way).

Because the server doesn't store statistics, the MySQL query optimizer has to ask the engines for statistics on the tables in a query. The engines provide the optimizer with statistics such as the number of pages per table or index, the cardinality of tables and indexes, the length of rows and keys distribution information. The optimizer can use this information to help it decide on the best execution plan. 

### MySQL's join execution strategy

MySQL uses the term "join" more broadly than you might be used to. In sum, it considers every query a join - not just every query that matches rows from two tables, but every query, period (including subqueries, and even a `SELECT` against a single table). Consequently, it's very important to understand how MySQL executes joins.

Consider the example of a UNION query. MySQL executes a UNION as a series of single queries whose results are spooled into a temporary table, then read out again. Each of the individual queries is a join, in MySQL terminology - and so is the act of reading from the resulting temporary table. Consequently, it's very important to understand how MySQL executes joins.

## The Query Execution Engine

The parsing and optimizing stage outputs a query execution plan, which MySQL's query execution engine uses to process the query. The plan is a data structure; it is not executable byte-code, which is how many other databases execute queries.

Many of the operations in the plan invoke methods implemented by the storage engine interface, also known as the handler API. Each table in the query is represented by an instance of a handler. If a table appears three times in the query, for example, the server creates three handler instances. Though we glossed over this before, MySQL actually creates the handler instances early in the optimization stage.

The storage engine interface has lots of functionality, but it needs only a dozen or so "building-block" operations to execute most queries. For example, there's an operation to read the first row in an index, and one to read the next row in an index.

Not everything is a handler operation. For example, the server manages table locks. The handler might implement its own lower-level locking, as InnoDB does with row-level locks, but this does not replace the server's own locking impl.

### Returning Results to the Client

The final step in executing a query is to reply to the client. Event queries that don't return a result set still reply to the client connection with information about the query, such as how many rows it affected.

If the query is cacheable, MySQL will also place the results into the query cache at this stage.

The server generates and sends results incrementally. Think back to the single-sweep multijoin method we mentioned earlier. As soon as MySQL processes the last table and generates one row successfully, it can and should send that row to the client.

This has two benefits: it lets the server avoid holding the row in memory, and it means the client starts getting the results as soon as possible.

Each row in the result set is sent in a separate packet in the MySQL client/server protocol, although protocol packets can be bufffered and sent together at the TCP protocol layer.

## Limitations of MySQL Query Optimizer

## Query Optimizer Hints

## Optimizing Specific Types of Queries

## Case Studies

Sometimes it's not about query optimization, schema optimization, index optimization, or application design optimization - it's about all of these practices put together. The case studies in this section illustrate how to approach some design challenges that frequently cause problems for users.

### Bulding a Queue Table in MySQL

Building a queue in MySQL is tricky, and most designs we've seen don't work well when the system experiences high traffic and lots of concurrency. The typical pattern is to have a table that contains several types of rows: rows that haves been processed, rows in process, and finished rows. One or more worker processes look for unprocessed rows, update them to "claim" them, and then perform the work and update them to mark them as finished. 

There are two broad reasons why this doesn't work well. First, the table tends to grow very large, and searching for the unprocessed rows becomes slow when the table is large and the indexes are many levels deep. You can slove this by splitting the queue into two tables and moving the completed rows to the archieve or history table.  

## Summary
