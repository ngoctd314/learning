# Why are queries slow?

Schema optimization and indexing are not enough, you also need to design your queries well. If your queries are bad, even the best designed schema and indexes will not perform well.

Query optimization, index optimization, and schema optimization go hand in hand. As you gain experience writing queries in MySQL, you will learn how to design tables and indexes to support efficient queries.

Before trying to write fast queries, remember that it's all about response time. Queries are tasks, but they are composed of subtasks, and those subtasks consume time, making them happen fewer times, or making them happen more quickly.

What are the subtasks that MySQL performs to execute a query, and which ones are slow? While accomplishing all these tasks, the query sends time on the network, in the CPU, in operations such as statistics and planning, locking (mutex waits) and most especially, calls to the storage engine to retrieve rows. These calls consume time in memory operations, CPU operations, and especially I/O operations if the data isn't in memory. Depending on the storage engine, a lot of context switching and/or system calls might also be involved.

## Show query basics: Optimize Data Access

The most basic reason a query doesn't perform well is because it's working with too much data. Some queries just have to sift through a lot of data and can't be helped. Most bad queries can be changed to access less data. We've found it useful to analyze a poorly performing query in two steps:

1. Find out whether your application is retrieving more data than you need. That usually means it's accessing too many rows, but it might also be accessing too many columns.
2. Find out whether the MySQL server is analyzing more rows than it needs.

### Are you asking the database for data you don't need

This demands extra work of the MySQL server, adds network overhead, and consumes memory and CPU resources on the application server.

**Network overhead is worst if the application is on a different host from the server, but transferring data between MySQL and the application isn't free event if they're on the same server.**

- Fetching more rows than needed

One common mistake is assuming that MySQl provides results on demand, rather than calculating and returning the full result set. These developers are used to techniques such as issuing a SELECT statement that returns many rows, then fetching the first N rows and closing the result set (e.g. fetching the 100 most recent articles for a news site when they only need to show 10 of them on the front page). They think MySQL will provide them with these 10 rows and stop executing the query, but what MySQL really does is generate these 10 rows and stop executing the query, but what MySQL really does is generate the complete result set. The client lib then fetches all the data and discards most of it. The best solution is to add a LIMIT clause to the query

- Fetching all columns from a multi-table join

If you want to retrieve all actors who appear in the film Academy Dinosaur, don't write the query this way:

```sql
SELECT * FROM sakila.actor
INNER JOIN sakila.film_actor USING (actor_id)
INNER JOIN sakila.film USING (film_id)
WHERE sakila.film.title = "Academy Dinosaur";
```
That returns all columns from all three tables. Instead, write the query as follows:

```sql
SELECT sakila.actor.* FROM sakila.actor...;
```

- Fetching all columns

You should always be suspicious when you see SELECT *. Do you really need all columns? Probably not. Retrieving all columns can prevent optimizations such as covering indexes, as well as adding I/O, memory, and CPU overhead for the server.

Some DBAs ban SELECT * universally becaus of this fact, and to reduce the risk of problems when someone alters the table's column list.

- Fetching the same data repeatedly

If you're not careful, it's quite easy to write application code that retrieves the same data repeatedly from the database server.

## Is MySQL examining Too much data

In MySQL the simplest query cost metrics are:

- Response time
- Number of rows examined
- Number of rows returned

Looking at the slow query log is one of the best ways to find queries that examine too much data.

### Response time

Response time if the sum of two things: service time and queue time. Service time is how long it takes the server to actually process the query. Queue time is the the portion of response time during which server isn't really executing the query - it's waiting for something such as waiting for an I/O operation to complete, waiting for a row lock, and so forth.

### Rows examined and rows returned

### Rows examined and access types

You don't need to memorize the access types, but you should understand the general concepts of scanning a table, scanning an index, range access, and single value access.