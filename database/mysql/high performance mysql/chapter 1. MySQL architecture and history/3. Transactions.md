# Transactions

A transaction is a group of SQL queries that are treated atomically, as a single unit of work.

Transaction aren't enough unless the system passes the ACID test. ACID stands for Atomicity, Consistency, Isolation and Durability.

**Atomicity**
A transaction must function as a single indivisible unit of work so that the entire transaction is either applied or rolled back. When transactions are atomic, there is no such thing as a partially completed transaction: it's all or nothing.

**Consistency**
The database should always move from one consistent state to the next. When the transaction is never committed, none of the transaction's changes are ever reflected in the database.

**Isolation**
The results of a transaction are usually invisible to other transactions until the transaction is complete. When we discuss isolation levels, you'll understand why we said usually invisible.

**Durability**
Once committed, a transaction's changes are permanent. This means the changes must be recorded such that data won't be lost in a system crash.

ACID transactions ensure that banks don't lose your money. It is generally extremely difficult or impossible to do this with application logic.

Just as with increased lock granularity, the downside of this extra security is that the database server has to do more work. A database server with ACID transactions also generally requires more CPU power, memory, and disk space than one without them. You can decide whether your application needs transaction. If you don't really need them, you might be able to get higher performance with a non-transactional storage engine for some kinds of queries. You might be able to use LOCK TABLES to give the level of protection you need without transactions.

## Isolation levels

Isolation is more complex than it looks. The SQL standard defines four isolation levels, with specific rules for which changes are and aren't visible inside and outside a transaction. Lower isolation levels typically allow higher concurrency and have lower overhead.

Each storage engine implements isolation levels slightly differently, and they don't necessarily match what you might expect if you're used to another database product. You should read the manuals for whichever storage engines you decide to use.

**READ UNCOMMITTED**

In the READ UNCOMMITTED isolation level, transactions can view the results of uncommitted transactions. At this level, many problems can occur unless you really, really known what you are doing and have a good reason for doing it. This level is rarely used in practice, because it performance isn't much better than the other levels, which have many advantages. Reading uncommitted data is also known as a dirty read???.

**READ COMMITTED**

The default isolation level for most database systems (but not MySQL) is READ COMMITTED. It satisfied the simple definition of isolation used earlier: a transaction will see only those changes made by transactions that were already committed when it began, and its changes won't be visible to others until is has committed. This level is still allows what's known as non-repeatable read???. This means you can run the same statement twice and see the different data.

**REPEATABLE READ**

REPEATABLE READ solves the problems that READ UNCOMMITTED allows. It guarantees that any rows a transaction reads will "look the same" in subsequent reads within the same transaction, but in theory it still allows another tricky problem: phantom reads. Simply put, a phantom read can happen when you select some range or rows, another transaction inserts a new row into the range, and then you select the same range again; you will see the new "phantom" row. InnoDB and XtraDB solve the phantom read problem with multi-version concurrency control, which we ex-plain later in this chapter.

REPEATABLE READ is MySQL's default transaction isolation level.

**SERIALIZATION**

The highest level of isolation level, SERIALIZABLE, solves the phantom read problem by forcing transactions to be ordered so that they can't possibly conflict. In a nutshell, SERIALIZABLE places a lock on every row it reads. At this level, a lot of timeouts and lock contention can occur. We've rarely seen people use this isolation level, but your application's needs might force you to accept the decreased concurrency in favor of the data stability that result.