# Prepared Statements

MySQL 4.1 and newer support server side prepared statements that use an enhanced binary client/server protocol to send data efficiently between the client and server.

When you create a prepared statement, the client library sends the server a prototype of the actual query you want to use. The server parses and process this "skeleton" query, stores a structure representing the partially optimized query, and returns a statement handle to the client. The client library can execute the query repeatedly by specifying the statement handle.

Prepared statements can have parameters, which are question-mark placeholders for values that you can specify when you execute them. For example, you might prepare the following query:

```sql
INSERT INTO tbl(col1, col2, col3) VALUES (?, ?, ?);
```

You could then execute this query be sending the statement handle to the server, with values for each of the question-mark placeholders. You can repeat this as many times as desired.

Using prepared statements can be more efficient than executing a query repeatedly, for several reasons:

- The server has to parse the query only once.
- The server has to perform some query optimization steps only once, as it caches a partial query execution plan.
- Sending parameters via the binary protocol is more efficient than sending them as ASCII text. For example, a DATE value can be sent just 3 bytes, instead of the 10 bytes required in ASCII. The biggest savings are for BLOG and TEXT values, which can be sent to the server in chunks rather than as the client, as well as reducing network traffic and the overhead of converting between the data's native storage format and the non-binary protocol's format.
- Only the parameters - not the entire query text - need to be sent for each execution, which reduces network traffic.
- MySQL stores the parameters directly into buffers on the server, which eliminates the need for the server to copy values around in memory.

Prepared statements can also help with security. There is no need to escape or quote values in the application, which is more convenient and reduces vulnerability to SQL injection or other attacks. ( You should never trust user input, even when you're using prepared statement).

You can use binary protocol only with prepared statements.

## Prepared statement optimization

MySQL caches partial query execution plans for prepared statements, but some optimizations depend on the actual values that are bound to each parameter and therefore can't be precomputed and cached. The optimizations can be separated into three types, based on when they must be performed. The following list applies at the time of this writing:

At preparation time
    The server parses the query text, eliminates negations, and rewrites sub-queries

At first execution
    The server simplifies nested joins and converts OUTER JOINs to INNER JOINs where possible

At every execution
    - Prunes partitions
    - Eliminates COUNT(), INT(), and MAX() where possible
    - Removes constant sub-expressions
    - Detects constant tables
    - Propagates equalities
    - Analyzes and optimizes ref, range, and index_merge access methods
    - Optimizes the join order

```go
stmt, _ := db.Prepare("SELECT * FROM sales WHERE order_date > '2010-10-10' LIMIT 10")
rows, err := stmt.Query()
if err != nil {
    log.Println(err)
}
```
## The SQL interface to Prepared Statements

When the server receives these statements, it translates them into the same operations that would have been involved by the client library. This means that you don't have to use the special binary protocol to create and execute prepared statements.    

The syntax is little awkward compared to just typing the SELECT statement directly. So what's the advantage of using a prepared statement this way?

The main use case is for store procedures. In MySQL 5.0 you can use prepared statements in stored procedures, and the syntax is similar to the SQL interface. This means you can build and execute "dynamic SQL" in stored procedures by concatenating strings, which makes stored procedures much more flexible.

## Limitations of Prepared Statements

Prepared statements have a few limitations and caveats:

- Prepared statements are local to a connection, so another connection cannot use the same handle. For the same reason, a client that disconnects and reconnects loses the statements. (Connection pooling or persistent connections can alleviate this problem).
- Prepared statements cannot use the query cache in MySQL.
- It's not always more efficient to use prepared statements. If you use a prepared statement only once, you might spend more time preparing it than you would just executing is as normal SQL. Preparing a statement also requires two extra round-trips to the server (to use prepared statements properly, you should de-allocate them after use).
- You cannot currently use a prepared statement inside a stored function
- You can accidentally "leak" a prepared statement by forgetting to de-allocate it. This can consume a lot of resources on the server. Also, because there is a single global limit on the number of prepared statements, a mistake such as this can interfere with other connection's use of prepared statements.
- Some operations, such as BEGIN, cannot be performed in prepared statements.

**Client-side emulated**
The client driver accepts string with placeholders, then substitutes the parameters into the SQL and sends the resulting query to the server.

**Server-side**
The driver sends a string with placeholders to the server with a special binary protocol, receives back a statement identifier, then executes the statement over the binary protocol by specifying the identifier and the parameter.

**SQL interface**
The client sends a string with placeholders to the server as a PREPARE SQL statement, sets SQL variables to parameter values, and finally executes the statement with an EXECUTE SQL statement.

