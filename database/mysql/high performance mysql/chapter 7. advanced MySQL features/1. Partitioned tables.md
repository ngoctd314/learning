# Partitioned Tables

A partitioned table is a single logical table that's composed of multiple physical sub-tables. The partitioning code is really wrapper around a set of Handler objects that represent the underlying partitions, and it forwards requests to the storage engine through the Handler object.

They way MySQL implements partitioning - as a wrapper over hidden tables - means that indexes are defined per-partition, rather than being created over the entire table.

MySQL decides which partition holds each row of data based on the PARTITION BY clause that you define for the table. The query optimizer can prune partitions when you execute queries, so the queries don't examine all partitions - just the ones that hold data you are looking for.

Partitioning can be very beneficial, especially in specific scenarios:

- When the table is much too big to fit in memory, or when you have "hot" rows at the end of a table that has lots of historical data. 
- Partitioned data is easier to maintain than non-partitioned data. For example, it's easier to discard old data by dropping an entire partition, which you can do quickly. You can also optimize, check, and repair individual partitions.
- Partitioned data can be distributed physically, enabling the server to use multiple hard drives more efficiently
- You can use partitioning to avoid some bottlenecks in specific workloads, such as per-index mutexes with InnoDB or per-inode locking with the ext3 filesystem.
- If you really need to, you can back up and restore individual partitions, which is very helpful with extremely large datasets.

A few limitations apply to partitioned tables. Here are the most important ones:

- There's a limit of 1.024 partitions per table.
- Any primary key or unique index must include all columns in the partitioning expression.
- You can't use foreign key constraints

## How Partitioning Works

Partitioned tables have multiple underlying tables, which are represented by Handler object. You can't access the partitions directly. Each partition is managed by the storage engine in the normal fashion (all partitions must use the same storage engine), and any indexes defined over the table are actually implemented as identical indexes over each underlying partition. From the storage engine's point of view, the partitions are just tables; the storage engine doesn't really know whether a specific table it's managing is a standalone table or just part of a bigger partitioned table.

Operations on a partitioned table are implemented with the following logical operations:

**SELECT queries**

When you query a partitioned table, the partitioning layer opens and locks all of the underlying partitions, the query optimizer determines whether any of the partitions can be ignored (pruned), and then partitioning layer forwards the handler API calls to the storage engine that manager the partitioned. 

**INSERT queries**

When you insert a row, the partitioning layer opens and locks all partitions, determines which partition should receive the row, and forwards the row to that partition.

**DELETE queries**

When you delete a row, the partitioning layer opens and locks all partitions, determines which partition contains the row, and forwards the deletion request to that partition.

**UPDATE queries**

When you modify a row, the partition layer (you guessed it) opens and locks all partitions, determines which partition contains the row, fetches the row, modifies the row and determines which partition should contain the new row, forwards the row with an insertion request to the destination partition, and forwards the deletion request to the source partition. 

Although the partitioning layer opens and locks all partitions, this doesn't mean that the partition remain locked. A storage engine such as InnoDB, which handles its own locking at the row level, will instruct the partitioning layer to unlock the partitions.

## Type of Partitioning

MySQL supports several types of partitioning. The most common type we've seen used is range partitioning, in which each partition is defined to accept a specific range of values for some column or columns, or a function over those columns.

```sql
CREATE TABLE sales (
    order_date DATETIME NOT NULL,
    -- Other columns omitted
) ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date)) (
    PARTITION p_2010 VALUES LESS THAN (2010),
    PARTITION p_2011 VALUES LESS THAN (2011),
    PARTITION p_2012 VALUES LESS THAN (2012),
    PARTITION p_catchall VALUES LESS THAN MAXVALUE);
```

You can use many functions in the partitioning clause. The main requirement is that it must return a non-constant, deterministic integer. We're using YEAR() here, but you can also use other functions, such as TO_DAYS(). Partitioning by intervals of time is a common way to work with date-based data, so we'll return to this example later and see how to optimize it to avoid some of the problems it can cause.

MySQL also support keys, hash, and list partitioning methods, some of which support sub-partitions.

One use of sub-partitions we've seen to work a per-index mutex inside Inno-DB on a table designed similarly to our previous example. The partition for the most recent year was modified heavily, which caused a lot of contention on that mutex.

## How to Use Partitioning

Imagine that you want to run queries over ranges of data from a really huge table that contains many year's worth of historical metrics in time-series order. You want to run reports on the most recent month, which is about 100 million rows.

One thing is sure: you can't scan the whole table every time you want to query it, because it's too big. And you don't want to use an index because of the maintenance cost and space consumption. Depending on the index, you could get a log of fragmentation and poorly clustered data, which would cause death by a thousand cuts through random I/O. You can sometimes work around this for one or two indexes, but really for more. Only two workable options remain: your query must be a sequential scan over a portion of the table, or the desired portion of the table and index must fit entirely in memory.

It's worth restarting this: at very large sizes, B-Tree indexes don't work. Unless the index covers the query completely, the server needs to look up the full rows in the table, and that causes random I/O a row at a time over a very large space, which will just kill query response time. The cost of maintaining the index (disk space, I/O operations) is also very high.

This is what partitioning can accomplish, too. The key is to think about partitioning as a crude form of indexing has very low overhead and gets you in the neighborhood of the data you want. From there, you can either scan the neighborhood sequentially, or fit the neighborhood in memory and index it. Partitioning has low overhead because there is no data structure that points to rows and must be updated. 

Let's look at the two strategies that work at large scale:

**Scan the data, don't index it:**

You can create tables without indexes and use partitioning as the only mechanism to navigate to the desired kind of rows. As long as you always use a WHERE clause that prunes the query to a small number of partitions, this can be good enough.

**Index the data, and segregate hot data**

If your data is mostly unused except for "hot" portion, you can partition so that the host data is store in a single partition that is small enough to fit in memory along with its indexes, you can add indexes and write queries to take advantages of them, just as you would with smaller tables.

## What can go Wrong

The two partitioning strategies we just suggested are based on two key assumptions: that you can narrow the search by pruning partitions when you query, and that partition itself is not very costly. AS it turns out, those assumptions are not always valid. Here are a few problems you might encounter:

**NULLs can defeat pruning:**

Partition works in a funny way when the result of the partitioning function can be NULL: it treats the first partition as special. Suppose that you PARTITION BY RANGE YEAR(order_date), as in the example we gave earlier. Any row whose order_date is either NULL or not a valid date will be stored in the first partition you define. Now suppose you write a query that ends as follows: WHERE order_date BETWEEN '2012-01-01' AND '2012-01-31'. MysQL will actually check two partitions, not one: it will look at the partition that stores orders from 2012, as well as the first partition in the table. It looks at the first partition because YEAR() function can return NULL if it receives invalid input, and values that might match the range would be stored as NULL in the first partition. This affects other functions, such as TO_DAYS() too.

This can be expensive if your first partition is large, especially if you're using the "scan, don't index" strategy. Checking two partitions instead of one to find the rows is definitely undesirable. To avoid this, you can define a dummy first partition. That is, we could fix our earlier example by creating a partition such as PARTITION p_nulls VALUE LESS THAN (0). If you don't put invalid data into your table, that partition will be empty, and although it'll be checked, it'll be fast because it's empty.

**Mismatched PARTITION BY and index**

If you define an index that doesn't match the partitioning clause, queries might nor be prunable. Suppose you define an index on a and partition by b. Each partition will have its own index, and a lookup on this index will open and check each index tree in every partition. This could be quick if the non-leaf nodes of each index are resident in memory, but it is nevertheless more costly that skipping the index lookups completely.