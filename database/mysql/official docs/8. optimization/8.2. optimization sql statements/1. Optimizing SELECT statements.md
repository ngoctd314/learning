# Optimizing SELECT statements

## WHERE Clause Optimization 

Processing WHERE clauses. The examples use SELECT statements, but the same optimizations apply for WHERE clauses in DELETE and UPDATE statements.

You might be tempted to rewrite your queries to make arithmetic operations faster, while sacrificing readability. Because MySQL does similar optimizations automatically, you can often avoid this work, and leave the query in a more understandable and maintainable form.

- Removal of unnecessary parentheses:

```sql
((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)
```

- Constant folding:
```sql
(a < b AND b=c) AND a=5
-> b > 5 AND b=c AND a=5
```

- Constant condition removal
```sql
(b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6
```

- Constant expressions used by indexes are evaluated only once
- Beginning with MySQL 8.0.16 comparisons of columns of numeric types with constant value are checked and folded or removed for invalid or out-of-range values:

```sql
SELECT * FROM t WHERE c << 256
-> SELECT * FROM t WHERE 1;
```

- COUNT(*) on a single table without a WHERE is retrieved directly from the table information for MyISAM and MEMORY tables.
- Early detection of invalid constant expressions. MySQL quickly detects that some SELECT statements are impossible and returns no rows.
- HAVING is merged with WHERE if you do not use GROUP BY or aggregate functions (COUNT(), MIN()), and so on).
- For each table in a join, a simpler `WHERE` is constructed to get a fast `WHERE` evaluation for the table and also to skip rows as soon as possible.
- All constant tables are read first before any other tables in the query. A constant table is any of the following: An empty table or a table with one row, a table that is used with a `WHERE` clause on a `PRIMARY KEY` or a `UNIQUE`, where all index parts are compared to constant expressions are defined as NOT NULL. 

All of the following tables are used as constant tables:

```sql
SELECT * FROM t WHERE primary_key=1;
SELECT * FROM t1,t2
    WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
```

- The best join combination for joining the tables is found by trying all possibilities. If all columns in `ORDER BY` and `GROUP BY` clauses come from the same table, that table is preferred first when joining.

TODO: example
```sql

```

- If there is an `ORDER BY` clause and a different `GROUP BY` clause, or if the `ORDER BY` or `GROUP BY` contains columns from tables other than the first table in the join queue, a temporary table is created.

- If you use the `SQL_SMALL_RESULT` modifier, MySQL uses an in-memory temporary table.

- Each table index is queried, and the index is used unless the optimizer belives that it is more efficient to use a table scan. At one time, a scan was used used based on whether the best index spanned more than 30% of the table, but a fixed percentage no longer determines the choice between using an index or a scan. The optimizer now is more complex and based its estimate on additional factors such as table size, number of rows, and I/O block size.

- In some cases, MySQL can read rows from the index without even consulting the data file. If all columns used from the index are numeric, only the index tree is used to resolve the query.

- Before each row is output, those that do not match the `HAVING` clause are skipped.

```sql
SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1), MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
    WHERE key_part1=constant;

SELECT ... FROM tbl_name
    ORDER BY key_part1, key_part2, ... LIMIT 10;

SELECT ... FROM tbl_name
    ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
```

MySQL resolves the following queries using only the index tree, assuming that the indexed columns are numeric:

```sql
SELECT key_part1, key_part2 FROM tbl_name WHERE key_part1=val;

SELECT COUNT(*) FROM tbl_name
    WHERE key_part1=val1 AND key_part2=val2;

SELECT MAX(key_part2) FROM tbl_name GROUP BY key_part1;
```

The following queries use indexing to retrieve the rows in sorted order without a separate sorting pass:

```sql
SELECT ... FROM tbl_name
    ORDER BY key_part1, key_part2, ...;

SELECT ... FROM tbl_name
    ORDER BY key_part1 DESC, key_part2 DESC, ...;
```

## Range Optimization

The range access method uses a single index to retrieve a subset of table rows that are contained one or several index value internals. It can be used for a single-part or multiple-part index. The following sections describe conditions under which the optimizer uses range access.

### Range Access Method for Single-Part Indexes

For a single-part index, index value intervals can be conveniently represented by corresponding conditions in the `WHERE` clause, denoted as range conditions rather than "intervals."

The definition of a range condition for a single-part index is as follows:

- For both BTREE and HASH indexes, comparison of a key part with a constant value is a range condition when using the <, >=, <=, BETWEEN, !=, or <> operators, or LIKE comparisons if the argument to LIKE is constant string that does not start with a wildcard character.

- For all index types, multiple range conditions combined with OR and AND form a range condition.

"Constant value" in the preceding descriptions means one of the following:

- A constant from the query string
- A column of a constant or system table from the same join
- The result of an uncorrelated subquery
- Any expression composed entirely from subexpressions of the preceding types

```sql
SELECT * FROM t1 WHERE key_col > 1 AND key_col < 10;

SELECT * FROM t1 WHERE key_col = 1 OR key_col IN (15, 18, 20);

SELECT * FROM t1 WHERE key_col LIKE 'ab%' OR key_col BETWEEN 'bar' AND 'foo';
```

Some nonconstant values may be converted to constants during the optimizer constant propagation phase.

MySQL tries to extract range conditions from the `WHERE` clause for each of the possible indexes. During the extraction process, conditions that cannot be used for constructing the range condition are dropped, conditions that produce overlapping ranges are combined, and combinations that produce empty ranges are removed.

Consider the following statement, where key1 is an indexed column and nonkey is not indexed:

```sql
SELECT * FROM t1 WHERE
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z');
```

The extraction process for key key1 is follows:

1. Start with original `WHERE` clause:

```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```

2. Remove nonkey = 4 and key1 LIKE '%b' because they cannot used for a range scan. The correct way to remove them is to replace them with TRUE, so that we do not miss any matching rows when doing the range scan. Replacing them with TRUE yields:

```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1< 'uux' AND key1 > 'z')
```

3. Collapse conditions that are always true or false:

- (key1 LIKE 'abcde%' OR TRUE) is always true
- (key1 < 'uux' AND key1 > 'z') is always false

Replacing these conditions with constants yields:

```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```

Removing unnecessary TRUE and FALSE constants yields:

```sql
(key1 < 'abc') OR (key1 < 'bar')
```

Combining overlapping intervals into one yields the final condition to be used for the range scan:

```sql
(key1 < 'bar')
```

### Range Access Method for Multiple-Part Indexes

Range conditions on a multiple-part index are an extension of range conditions for a single-part index. A range condition on a multiple-part index restricts index rows to lie within one or several key tuple intervals. 

For example, consider a multiple-part index defined as key1(key_part1, key_part2, key_part3), and the following set of key tuples listed in key order:

```txt
key_part1 key_part2 key_part3
NULL      1         'abc'
NULL      1         'xyz'
1         1         'abc'
1         1         'xyz'
1         2         'abc'
2         1         'aaa'
```

The condition key_part1 = 1 defines this interval:

The interval covers the 4th, 5th, and 6th tuples in the preceding data set and can be used by the range access method. By contrast, the condition key_part3 = 'abc' does not define a single interval and cannot be used by the range access method.

The following descriptions indicate how range conditions work for multiple-part indexes in greater detail.

### Equality Range Optimization of Many-Valued Comparisons

Consider these expressions, where col_name is an indexed column:

```txt
col_name IN (val1, ..., valN)
col_name = val1 OR ... OR col_name = valN
```

Each expression is true if col_name is equal to any of several values.

- If there is a unique index on col_name, the row estimate for each range is 1 because at most one row can have the given value.
- Otherwise, any index on col_name is nonunique and the optimizer can estimate the row count for each range using dives into the index or index statistics.

With index dives, the optimizer makes a dive at each end of a range and uses the number of rows in the range as the estimate. For example, the expression col_name IN (10, 20, 30) has three equality ranges and the optimizer makes two dives per range to generate a row estimate.

TODO: read again

### Skip Scan Range Access Method

Consider the following scenario:

```sql
CREATE TABLE t1 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY(f1, f2));
INSERT INTO t1 VALUES
    (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),
    (2,1), (2,2), (2,3), (2,4), (2,5);
INSERT INTO t1 SELECT f1, f2 + 5 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 10 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 20 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 40 FROM t1;
ANALYZE TABLE t1;

EXPLAIN SELECT f1, f2 FROM t1 WHERE f2 > 40;
```

To execute this query, MySQL can choose an index scan to fetch all rows (the index includes all columns to be selected), then apply the f2 > 40 condition from the WHERE clause to produce the final result set. A range scan is more efficient than a full index scan, but cannot be used in this case before there is no condition on f1, the first index column.

1. Skip between distinct values of the first index part, f1 (the index prefix).

### Range Optimization of Row Constructor Expressions

### Limit Memory Use for Range Optimization

## Index Merge Optimization

The Index Merge access method retrieves rows with multiple range scans and merges their results into one. This access method merges index scans from a single table only, not scans across multiple tables.

## Hash Join Optimization

## Index Condition Pushdown Optimization

## Nested-Loop Join Algorithms

MySQL executes joins between tables using a nested-loop algorithm or variations on it.

### Nested-Loop Join Algorithm

A simple nested-loop join (NLJ) algorithm reads rows from the first table in a loop one at a time, passing each row to a nested loop that processes the next table in the join. This process is repeated as many times as three remain tables to be joined.

Assume that a join between three table t1, t2, and t3 is to be executed using the following join types:

```txt
Table Join Type
t1    range
t2    ref
t3    ALL
```

If a simple NLJ algorithm is used, the join is processed like this:

```go
for each row in t1 matching range {
    for each row in t2 matching reference key {
        for each row in t3 {
            if row satisfies join conditions, send to client
        }
    }
}
```

Because the NLJ algorithm passes rows one at a time from outer loops to inner loops, it typically reads tables processed in the inner loops many times.

### Block Nested-Loop Join Algorithm

A Block Nested-Loop (BNL) join algorithm uses buffering of rows read in outer loops to reduce the number of times that tables in inner loops must be read. For example, if 10 rows are read into a buffer and the buffer is passed to the next inner loop, each row read in the inner loop can be compared against all 10 rows in the buffer. This reduces by an order of magnitude the number of times the inner table must be read.

## Nested Join Optimization

The syntax for expressing joins permits nested joins.

