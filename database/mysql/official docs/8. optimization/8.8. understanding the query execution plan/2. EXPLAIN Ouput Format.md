# EXPLAIN Output Format

EXPLAIN returns a row of information for each table used in the SELECT statement. It lists the tables in the output in the order that MySQL would read them while processing the statement. This means that MySQL reads a row from the frist table, then finds a matching row in the second table, and then in the third table, and then in the third table, and so on.

## EXPLAIN Output Columns

This section describes the output columns produced by EXPLAIN.

## EXPLAIN Join Types

The type column of EXPLAIN output describes how tables are joined. In JSON-formatted output, there are found as values of the access_type property. The following list describes the join types, ordered from the best type to the worst: 

**- system**
The table has only one row(=system table). This is a special case of the const join type

Example: null

**- const**
The table has at most one matching row which is read at the start of the query(compile time). Because there is only one row, values from the column in this row can be regarded as constants by the rest of the optimizer. const tables are very fast because they are read only once.

const is used when you compare all parts of a PRIMARY KEY or UNIQUE index to constant values. In the following queries, tbl_name can be used as a const table:

```sql
CREATE TABLE example_table (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);

-- Insert a single row into the table
INSERT INTO example_table (id, name) VALUES (1, 'John Doe');

-- Query using the "system" join type
EXPLAIN SELECT * FROM example_table WHERE id = 1;
```

**- eq_ref**
This join type is used for indexed lookups on unique not null or primary key indexes. It occurs when all parts of an index are used by the join, and only one matching row is expected.

```sql
create table tbl1 (id int auto_increment primary key);
create table tbl2 (id int auto_increment primary key);

explain select * from tbl1 join tbl2 on tbl2.id = tbl1.id;
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                   | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------------+------+----------+-------------+
| 1  | SIMPLE      | tbl1  | <null>     | index  | PRIMARY       | PRIMARY | 4       | <null>                | 3    | 100.0    | Using index |
| 1  | SIMPLE      | tbl2  | <null>     | eq_ref | PRIMARY       | PRIMARY | 4       | learn_explain.tbl1.id | 1    | 100.0    | Using index |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------------+------+----------+-------------+
```

**- ref**

```sql
CREATE TABLE tbl1 (
    id int AUTO_INCREMENT PRIMARY KEY,
    name varchar(255), 
    key idx_name(name)
);

INSERT INTO tbl1 (name) VALUES ('a'), ( 'b') ,( 'c'), ('a'), ('d');

EXPLAIN SELECT * FROM tbl1 WHERE name = 'a';
```

**- index_merge**

This join type indicates that the Index Merge optimization is used. In this case, the key column in the output row contains a list of indexes used, and key_len contains a list of the longest key parts for the indexes used.

```sql
CREATE TABLE tbl (id int auto_increment PRIMARY KEY, name varchar(255), age int, key idx_name(name), key idx_age(age));
INSERT INTO tbl (name, age) VALUES ('a', 1), ('d', 3), ('b', 4), ('f', 10), ('a', 12), ('b', 11);

EXPLAIN SELECT id FROM tbl where name = 'a' or age = 4;
+----+-------------+-------+------------+-------------+------------------+------------------+---------+--------+------+----------+--------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys    | key              | key_len | ref    | rows | filtered | Extra                                      |
+----+-------------+-------+------------+-------------+------------------+------------------+---------+--------+------+----------+--------------------------------------------+
| 1  | SIMPLE      | tbl   | <null>     | index_merge | idx_name,idx_age | idx_name,idx_age | 1023,5  | <null> | 3    | 100.0    | Using union(idx_name,idx_age); Using where |
+----+-------------+-------+------------+-------------+------------------+------------------+---------+--------+------+----------+--------------------------------------------+


CREATE TABLE tbl (id int auto_increment PRIMARY KEY, a int, b int, key idx_a(a), key idx_b(b));
INSERT INTO tbl (a, b) VALUES (1,2), (1, 3), (1,4), (1, 5), (1, 6), (2, 2), (2, 3), (2, 4), (2, 5), (3, 2), (3, 3), (3, 4), (3, 5), (4, 2), (4, 3), (4, 5);

EXPLAIN SELECT * FROM tbl WHERE a = 1 and b = 2;
+----+-------------+-------+------------+-------------+---------------+-------------+---------+--------+------+----------+--------------------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys | key         | key_len | ref    | rows | filtered | Extra                                                  |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+--------+------+----------+--------------------------------------------------------+
| 1  | SIMPLE      | tbl   | <null>     | index_merge | idx_a,idx_b   | idx_b,idx_a | 5,5     | <null> | 1    | 80.0     | Using intersect(idx_b,idx_a); Using where; Using index |
+----+-------------+-------+------------+-------------+---------------+-------------+---------+--------+------+----------+--------------------------------------------------------+
```

**- unique_subquery**

This type replaces eq_ref for some IN subqueries of the following form:

```sql
value IN (SELECT primary_key FROM single_table WHERE some_expr)
```

**- index_subquery**

**- range**

**- index**

```sql
EXPLAIN SELECT * FROM tbl1;
```

**- all**

## EXPLAIN Extra Information

The Extra column of EXPLAIN output contains additional information about how MySQL resolves the query.
