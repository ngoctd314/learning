# Type Embedding

## What is the Meaningfulness of Type Embedding?

The main purpose of type embedding is to extend the functionalities of the embedded types into the embedding type, so that we don't need to reimplement the functionalities of the embedded types for the embedding type.

Go chose the type embedding mechanism, and there is a big different between the two:

- If a type T inherits another type, then type T obtains the abilities of the other type. At the same time, each value of type T can also be viewed as a value of the other type.
- If a type T embeds another type, then type other type becomes a part of type T, and type T obtains the abilities of the other type, but none values of type T can be viewed as values of the other type.

## Does the Embedding Type Obtain the Fields and Methods of the Embedded Types?

```go
type Person struct {
	Name string
	Age int
}

func (p Person) PrintName() {
	fmt.Println("name:", p.Name)
}
func (p *Person) SetAge(age int) {
	p.Age = age
}

type Singer struct {
	Person
	works []string
}

func main() {
	t := reflect.TypeOf(Singer{})
	fmt.Println(t, "has", t.NumField(), "fields:")
	for i := 0; i < t.NumField(); i++ {
		fmt.Print(" field#", i, ": ", t.Field(i).Name, "\n")
	}
	fmt.Println(t, "has", t.NumMethod(), "methods:")
	for i := 0; i < t.NumMethod(); i++ {
		fmt.Print(" method#", i, ": ", t.Method(i).Name, "\n")
	}

	pt := reflect.TypeOf(&Singer{})
	fmt.Println(pt, "has", pt.NumMethod(), "methods:")
	for i := 0 ; i < pt.NumMethod(); i ++ {
		fmt.Print(" method#", i, ": ", pt.Method(i).Name, "\n")
	}
}
```

From the result, we know that the type Singer really owns a PrintName method, and the type *Single really owns two methods, PrintName and SetAge. But the type Singer doesn't own a Name field.

## Shorthands of Selectors

If a middle name in a selector corresponds to an embedded field, then that name can be ommited from the selector.