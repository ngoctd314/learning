# Compromising Authentication

Most websites provide some sort of login functionality. This is a form of authentication, the process of identifying users when they return to your website. Authenticating your users allows them to have an identity in an online community where they can contribute content, send messages to others, make purchases, and so on.

Nowadays, internet users are comfortable with signing up to site with signing up to a site with a username and password, and logging back in when they next want to use it. This is especially true since browsers and plug-ins help with caching or choosing passwords, and third-party authentication services have become ubiquitous.

There's a downside to this, however. Getting access to a user's account is a tantalizing prospect for hackers. In the age of the internet, it has never been easier for hackers to sell hacked credentials on the dark web, hijack social media accounts to spread clickbait, and commit financial fraud.

In this chapter, you'll investigate some of the ways that hackers can compromise a user's account on your site during the login and authentication process. (The next chapter covers the vulnerabilities your users face after they've logged in and established a session).

## Implementing Authentication

Authentication is part of the HyperText Transfer Protocol. To present an authentication challenge, a web server needs to return a 401 status code in the HTTP response and add a WWW-Authenticate header describing the preferred authentication method. (There are two commonly supported authentication methods: basic authentication and digest authentication.) To fulfill this requirement, the user agent - usually a web browser - needs to request a username and password from he user, thus creating the login functionality.

In the basic authentication scheme, the browser concatenates username and password supplied by the user with a colon (:) character between them, generating the string username:password. It then uses the Base64 algorithm to encode this string and send it back to the server in the Authorization header of an HTTP request.

The digest authentication scheme is a little more complex, and requires the browser to generate a hash consisting of the username, password and URL.

### HTTP-Native Authentication

Even though authentication is built into the HyperText Transfer Protocol, popular websites rarely use basic or digest authentication - mostly because of usability considerations. The native web browser authentication prompt is not a thing of beauty. It looks similar to a JS alert dialog, grabbing focus from the browser, and interrupting the experience of using the site.

Because browsers implement the authentication prompt outside HTML, we can't style the native authentication prompt to match the website. As a native browser window that doesn't appear in the web page, the browser also can't autocomplete the user's credentials. Finally, because HTTP authentication specifies no method of resetting a password if a user forgets it, we'd have to implement a reset feature separately from the login prompt, leading to a confusing user experience.

### Non-Native Authentication

Modern websites usually implement their own login forms in HTML. The supplied username and password are sent to the server as a POST request when the user submits the form. If the login is unsuccessful because the user couldn't be authenticated, the server replies with a 401 status code in the HTTP response. If the login is successful, the server redirects the user to their homepage.

### Brute-Force Attacks

Attackers often attempt to compromise your site at the point of authentication by guessing passwords. Hackers usually have move success using brute-force attacks, which use scripts to try thousands of commonly used passwords against a login page. Because previous data breaches have already leaked millions of commonly used passwords, it's easy for an attacker to determine which passwords they should try first.

## Mitigration

### Mitigration 1: Use Third-Party Authentication

The most secure authentication system is the one you don't have to write yourself. Instead of implementing your own authentication system, consider using a third-party service like Facebook login, which allows users to authenticate to your website with their social media credentials.

Large tech companies provide other similar authentication services. Most of them are based on the open authentication (OAuth) or OpenID standards - commonly implemented protocols for delegating authentication to a thrid party.

### Mitigration 2: Integrate with Single Sign-On

If you integrate with an OAuth or OpenID identity provider, your users will usually use their personal email addresses as usernames. However, if your website's target audience is business users, consider integrating with a single sign-on (SSO) identity provider like Okta, OneLogin, or Centrify, which centralizes authentication across enterprise systems so employees can login seamlessly to third-party applications under their business email.

### Mitigration 3: Secure Your Own Authentication System

Although 3rd authentication will usually be more secure than your own system, having only thrid-party authentication could somewhat limit your userbase because not everyone has a social media presence or Gmail. For everyone else, you'll need to create a way for them to sign up and manually choose a username and password. This means creating separate pages on your website where users can sign up, log in, and log out; plus writing code to store and update credentials in your database, and to check that the credentials are correct when a user reenters them.

That's a lot functionality to implement!

#### 1. Requiring Usernames, Email Address, or Both

**1.1. Validating Email Addresses**

**1.2. Banning Disposable Email Accounts**

Some users are reluctant to sign up with an email address they commonly use, and will sign up to your site using a temporary email account generated by services like 10 Minute. These types of services generate a disposable email account that's good for receiving a handful of messages before shutting down.

**1.3. Securing Password Resets**

#### 2. Requiring Complex Passwords

Complex passwords are generally harder to guess, so you should require users to meet certain password complexity standards when they choose a password, for their own protection.

#### 3. Securly Storing Passwords

**3.1. Hashing Passwords**

Passwords should be processed with a cryptographic hash algorithm before being stored in your database. This will convert the raw string of input text into a bit string of fixed length in such a way that makes it computationally unfeasible to reverse the process. You should then store the output values of that algorithm - the hashed values - alongside each username.

A good hashing algorithm should be quick to calculate, but not too quick. Otherwise, as computation speeds increase, brute-force attempts to crack the password by enumerating all possible inputs become feasible. For this section, a good algorithm to use is bcrypt, allows you to add extra iterations to the hashing function as the years go by to make it stronger and more time-consuming as computation power gets chapter.

**3.2. Salting Hashes**

Hashing passwords makes your site more secure, but users are frequently unimaginative in their password choice. When cracking password lists reverse engineering passwords for a list of leaked password hashed - hackers frequently use rainbow tables, which are lists of commonly used passwords that have been put through a known hashing algorithm. Matching hashes against precalculated values yield a very good return for an attacker, allowing them to determine the password for many, if not most, of the hashes. 

To protect against rainbow table attacks, you need to salt your password hashes, which means adding an element of randomness to the hashing algorithm so the input value in your configuration, or better yet, generate a salt input value separately for each user and store it alongside their password hash.

#### 4. Requiring Multifactor Authentication

No matter how securely you store password, password-based authentication systems are always vulnerable to brute-force password-guessing attacks. To really secure your website, consider adding an extra layer of security by requiring MFA. Which requires a returning user to identify themselves with at least two of the following three categories of information: something they know (PIN, OTP, Secure question), something they have (device), and something they are (biometrics).

**4.1. Implementing and Securing the Logout Function**

Your logout function should clear the session cookie in the browser, and invalidate the session identifier if you are storing it on the server side. This protect against attackers who manage to intercept session cookies after the fact and attempt to reastablish a session using a stolen cookie. Clearing the session cookie is as simple as sending back an HTTP response containing a Set-Cookie header with a blank value for your session parameter.

**4.2. Preventing User Enumeration**

You can cut down the risk of an attacker compromising your authentication system if they can't enumerating users, which means testing each username from a list to see whether it exists on your website. Attackers frequently use leaked credentials from prior hacks and attempt to verify whether any of these usernames exist on a target website. After they narrow down the list, they then proceed to guess passwords for usernames that matched.

**4.2.1. Preventing Potential Enumeration Vulnerabilities**

Login pages often allow an attacker to determine whether a username is taken on a site. If the page shows an error message for an incorrect password that differs from the error message for an unknown user, then an attacker can infer from the responses whether certain usernames correspond to accounts that exist on your site. It's important to keep the error message generic to avoid leaking this type of information.

Attackers may also use timing attacks to enumerate users by measuring HTTP response times. Hashing a password is a time-consuming operation; though it typically takes less than a second, it's still a meansurable amount of time. If your site calculates password hashes only when a user enters a valid username, an attacker can measure the slightly slower response time to infer which accounts exist on the site. Make sure your site calculates password hashes during authentication even for invalid usernames. 

You should prevent your password-reset screen from revealing that a username exists, too. If an attacker clicks a "Forgotten password" link and types in an email address to request a password-reset link, the response message on the page shouldn't reveal whether a reset email was sent. This prevents the attacker from knowning whether that email address is tied to an account on your site. Keep the message neutral: something like Check your inbox.

**4.2.2. Implementing CAPTCHA**

## Summary

Hackers often attempt to attack your authentication system in an effort to steal your user's credentials. To secure your website, you can use a 3rd party authentication system like Facebook Login or a sso identity provider.

If you're implementing your own authentication system, you'll need to have users choose a username and password upon sign-up. You should also store and validate an email address for each user. It makes sense to use this email as a username, unless you need users to have a visible display name.

The only reliable way to validate an email address is to send it an email containing link with a unique, temporary validation token that your site can check when user click it. Your password-secret mechanism for users who have forgotten their password should work in the same way.

You should process passwords with a cryptographic hash algorithm before storing them. You should also salt your password hashes to prevent rainbow table attacks.

Consider adding multifactor authentication if your site hosts sensitive data. Make sure to include a logout function somewhere on your site. Keep login failure messages generic, to prevent hackers from enumerating usernames on your site.
