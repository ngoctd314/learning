# Cross-site request forgery attacks

In the previous chapter, you saw how attackers use cross-site scripting attacks to inject JavaScript into a user's web browser through page elements like comment sections, search results, and URLs. Now you'll look at how attackers use malicious links to hack your users.

No website is an islannd. Because your website has a public URL, other sites will frequently link to it, which you should generally encourage as a site owner. More inbound links to your site means more traffic and better search engine rankings.

However, not everybody linking to your site has good intentions. An attacker can trick a user into clicking a malicious link that triggers undesirable or unexpected side effects. This is called cross-site request forgery (CSRF or XSRF). Security researchers sometimes pronounce CSRF as "sea-surf"

CSRF is a remarkably common vulnerability that most major websites have exhibited at one time or another. Attackers have used CSRF to steal Gmail contact lists, trigger one-click purchases on Amazon, and change router configuration 

## Anatomy of a CSRF Attack

Attackers usually launch CSRF attacks by exploiting websites that implement GET requests that change the state of a web server. A GET request is triggered when a victim clicks a link, allowing the attacker to craft misleading links into the target that perform unexpected actions. GET requests are the only type of HTTP request that contain the entirety of the request's content in a URL, so they're uniquely vulnerable to CSRF attacks.

One canny hacker used this loophold to create a viral worm on Twitter. Because they could use a single GET request to write a tweet, they constructed a malicious link tha, when clicked, would post a tweet containing an abscene message and the same malicious link. When readers of the tweet clicked the link that first victim tweeted, they too were tricked into tweeting the same thing.



In an early iteration of Twitter, you could create tweets via GET requests rather than POST requests this site currently uses. This oversight made Twitter vulnerable to CSRF attacks: it made it possible to create URL links that, when clicked, would post on a user's timeline.

## Mitigration 1: Follow REST Principles

To protect your users against CSRF attacks, make sure that your GET requests don't change the state of the server. Your website should use GET requests only to fetch web pages or other resources. You should perform actions  that change server state - for example, logging the user in or out, resetting passwords, writing posts, or closing an account - only through PUT, POST, or DELETE requests. This design philosophy, called Representational State Transfer (REST), comes with a host of other benefits besides CSRF protection.

REST states that you should map website operatiosn to the appropriate HTTP method according to their intention. You should fetch data or pages with GET requests, create new object on the server (such as comments, uploads, or messages) with PUT requests, modify objects on the server with POST requests, and delete objects with DELETE requests.

Not all actions have an obvious corresponding HTTP method. For instance, when a user logs in, it's a philosophical discussion as to whether the user is creating a new session or modifying their status. In terms of protecting against CSRF attacks, though, the key thing is to avoid assigning actions that change the server state to GET requests.

Protecting your GET requests doesn't mean that there aren't vulnerabilities in other types of requests as you'll see with our second mitigation.

## Mitigration 2: Implement Anti-CSRF Cookies

Defusing your GET requests shuts the door on most CSRF attacks, but you still need to protect against requests using the other HTTP verbs. Attacks using those verbs are much less common than GET-based CSRF attacks, and require much more work, but an attacker might try them if they might the payoff is sufficient.

FOr instance, they can trick a user into initiating a POST request to your site by having the victim submit a malicious form or script hosted on a thrid-party site under the attacker's control. If your site performs sensitive actions in response to POST requests, you need to use anti-CSRF cookies to ensure that these requests are initiated only from within your site. Sensitive actions should be triggered only from your own login forms and JS, rather than malicious pages that may tricker the user into performing unexpected actions.

An anti-CSRF cookie is a randomized string token that the web server writes out to a named cookie parameter. Recall that cookies are small pieces of text passed back and forth between the browser and web server in HTTP headers. If the web server returns an HTTP response containing a header value like Set-Cookie: _xsrf=5978e29d4ef434a1, the browser will send back the same information in the next HTTP request in a header with form Cookie: _xsrf=5978e29d4ef434a1.

Secure websites use anti-CSRF cookies to verify that POST requests originate from pages hosted on the same web domain. HTML pages on the site add this same string token as an <input type="hidden" name="_xsrf" value="5978e29d4ef434a1"> element in any HTML form used to generate POST requests.

## Mitigration 3: Use the SameSite Cookie Attribute

The final protection against CSRF attacks you must implement is to specify a SameSite attribute when you set cookies. By default, when a browser generates a request to your website, it will attach to the request the last known cookies that the site set, regardless of the source of the request. This means that malicious cross-site requests will arrive at your web server with any security cookies you previously set.  This doesn't defeat anti-CSRF measures in and of itself, but if an attacker steals the securiy token from your HTMl forms, and installs it in their own malicious forms, they can still launch a CSRF attack.

## Bonus Mitigration: Require Reauthentication for Sensitive Actions

## Summary
