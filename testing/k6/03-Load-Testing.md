# Load Testing

A common mistake in the industry is to use the terms performance testing and load testing interchangeably. They are not interchangeable! Rather, load testing is a sub-practice of performance testing.

**Performance testing != Load testing**

Performance testing verifies how well a system works as a whole, including aspects such as scalability, elasticity, availability, reliability, resiliency, and latency. Load testing is just one type of performance testing, and it is an approach that can be used to test many of aspects of application performance. However, not all performance testing involves load testing.

Load testing specifically focuses on verifying and validating the performance of an application while it has a significant volume of tasks to process. Load testing can be done manually, but most teams write automated load testing scripts to programmatically simulate real users accessing application.

## Test parameters

When writing load test scripts, you must consider many factors beyond the sheer amount of load to generate. These factors, called test parameters, include the distribution, shape, and pattern of the load.

Below is a non-exhaustive list of some common test parameters:

- Virtual users (VUs). A VU is an independent thread of execution that  runs concurrently to other VU threads. Often, scripts will be designed in such a way that 1 VU's activity represents that of 1 real user.
- Iterations. The total number of repetitions of the script to be executed by the VUs.
- Throughput. A measure of how much load test generates over time, usually defined in VUs per second, requests per second, or iterations per second.
- User flows. The actions that the script carries out, and the order the run in. In general, a user  flow represents the  path of a real user through the application. 
- Load profile. The shape of the traffic generated by the test over time. It includes the number of delays (in think time), the ramp-up and ramp-down periods when the test gradually increases the amount of VUs over time, and the stages of the test.
- Duration. The time it takes to run the entire test and its individual stages.

## How to simulate load

In general, you can simulate load in a few ways:

**Protocol-based load testing** simulates the underlying requests going to application servers. These requests are sent over the protocol layer. Protocol-based load testing varies in scope, including  both:

- Targeted API testing of one or more specific application components, and
- End-to-end or more realistic testing that simulates traffic flowing through the entire system, going through multiple components

**Browser-based load testing** on  the other hand, simulates the way users interact with application user interface.

**Hybrid load testing** is a mixture of protocol-based and browser-based testing. It's usually employed to test different aspects of performance. The most economical approach involves protocol-based load testing to generate the majority of  the load in conjunction with a smaller number of browser-based load testing users.

## Load test scenarios

### Smoke test

Is a small test that checks for major issues before spending more time and resources. A smoke test typically uses one or a few VUs that run  for a short  amount of time and checks for major issues such as:

- script-related problems that would significantly impact the accuracy of test results.
- unexpected environment configuration.
- significant application performance bottlenecks that raise at even low loads.

If a smoke test fails, any revealed issues must first be resolved before continuing to ramp up the test throughput.

### Average Load test

This scenario simulates the user workload during a typical hour in production. The scenarios includes the most frequently executed requests or functionalities within that hour.

This test scenarios typically includes ramp-up and ramp-down periods to simulate users gradually logging in and interacting with the system. The load test gradually increases the number of VUs until it reaches the desired load to mimic the average load behavior in production. 

Between the ramp-up and ramp-down periods is a steady state, a period when the number of virtual users is constant. In an average load test, the test sustains the steady-state load simulation for an hour or so.

![alt](./assets/test-scenario-average.png)

In the preceding example, the average load test was defined in terms of the number of VUs, but it can also be defined in terms of the number of iterations or requests per second that test generates.

### Stress test

A stress test, also known as a peak load test, simulates the traffic that the application is expected to experience at the highest point of the day or reason. While the average load test simulates the traffic on a typical day, aggregated over a week, month, or longer, a stress test focuses on the highest amount of traffic that the application experiences.

Though a stress test is similar to an average load test in shape, it usually generates a far higher test throughput. Consider an application that typically has 100 accessing users during "normal" hours, but 300 users during the lunch hour. This application might benefit from being tested with a stress test at the 300 VU level.

Stress tests are a good test scenario when testing rush hours or sale periods during when the application faces abnormally heavy load.

#### Soak or Endurance Test

Soak tests, also called endurance tests, are tests with a longer duration than average or peak tests. Some performance bottlenecks, such as ones caused by defeats in memory managment, apear only during longer periods of time. Soak tests verify whether performance degrades over time. 

This scenario tends to have similar test throughput levels to the average load test, but it is extended to a duration of several hours or even days, depending on the application.

![alt](./assets/test-scenario-soak.png)

#### Spike Test

The previous types of tests have all recreated a situation where load is introduced gradually (such as in the case of the average, stress, and soak tests) or where a small amout of load is executed (smoke test). A spike test, on the other hand, recreates a situation when the application experiences a sudden and massive increase in traffic.

Spike tests can be used to verify application performance during times when traffic goes from low to extremely high in a short amount of time. Spike tests are good for simulating timed events like:

- prominent product announcments (like in a Super Bowl ad)
- product launches or sale of concert tickets
- deadlines (last days of tax submissions)
- opening of sales seasons (Black Friday or Cyber Monday)

Spike tests have high thoughput and short steady-state situation. They generally have a negligible ramp-up and ramp-down period.

Another difference from the previous scenarios is the selection of user flows to be tested. Instead of a range of typical day-to-day processes, spike tests usually prioritize one user flow. For example, in an event ticket sale, users may focus on purchasing a ticket over browsing other pages. 

![alt](./assets/test-scenario-spike-test.png)

#### Breakpoint Test

While the previous load test types simulate realistic and expected production load, breakpoint tests attempt to go one step further. A breakpoint test exposes an application to increasing an application to increasing level of load in an attempt to identify the traffic level at which performance begins to degrade. 

A breakpoint test scenario focuses on the ramp-up period more than other scenario. It can consist entirely of a gradual ramp-up, or it can consist of periods of ramp-ups followed by periods of steady state.

![alt](./assets/test-scenarios-breakpoint.png)

Because breakpoint tests are more exploratory in nature, testers can't know in advance how many maximum VUs will be executed or how long the test will last. Teams typically monitor an application closely while a breakpoint test is running and either stop the test manually or program it to stop when it exceeds certain thresholds.
