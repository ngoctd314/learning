# 8.1.1. Basic networking

## Ethernet

Ethernet is a networking protocol, specified by the IEEE 802.3 standard. Most wired network interface cards (NICs) communicate using Ethernet.

In the OSI model of networking protocols, Ethernet occupies the second layer, which is known as the data link layer. When discussing Ethernet, you will often hear terms such as local network, layer 2, L2, link layer and data link layer.

In an Ethernet network, the hosts connected to the network communicate by exchanging frames. Every host on an Ethernet network is uniquely identified by an address called the MAC address. Every VM instance in an OpenStack environment has a unique MAC address, which is different from the MAC address of the compute host. A MAC address has 48 bits and is typically represented as a hexdecimal string such as 08:00:27:b9:88:74. The MAC address is hard-coded into the NIC by the manufacturer, although modern NICs allow you to change the MAC address programmatically. In Linux, you can retrieve the MAC address of a NIC using the ip command:

```txt
ip  link show wlp0s20f3
4: wlp0s20f3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000
    link/ether f0:d4:15:6b:e7:fc brd ff:ff:ff:ff:ff:ff
```

an Ethernet network as a single bus that each of the network hosts connects to. In early implementations, an Ethernet network consisted of a single coaxial cable that housts would tap into to connect to the network. However, network hosts in modern Ethernet networks connect directly to a network device called a switch. Still, this conceptual model is useful, and in network diagrams (including those generated by the OpenStack dashboard) an Ethernet network is often depicted as if it was single bus.

 In an Ethernet network, every host on the network can send a frame directly to every other host. An Ethernet network also supports broadcasts so that one host can send a frame to every host on the network by sending to special MAC address ff:ff:ff:ff:ff:ff. ARP and DHCP are two notable protocols that use Ethernet network referred to broadcast domain.

When a NIC receives an Ethernet frame, by default the NIC checks to see if the destination MAC address matches the address of the NIC (or the broadcast address), and the Ethernet frame is discarded if the MAC address does not match. For a compute host, this behavior is undesirable because the frame may be intended for one of the instances.

Modern Ethernet networks use switches to interconnect the network hosts. A switch is a box of networking hardware with a large number of ports that forward Ethernet frames from one connected host to another. When hosts first send frames over the switch, the switch doesn't know which MAC address is associated with which port. If an Ethernet frame is destinated for an unknown MAC address, the switch broadcasts the frame to all ports. The switch learns which MAC addresses are at which ports by observing the traffic. Once it knows which MAC address is associated with a port, it can send Ethernet frames to the correct port instead of broadcasting. The switch maintains the mapping of MAC addresses to switch ports in a table called a forwarding table or forwarding information base (FIB).

Switches can be daisy-chained together, and the resulting connection of switches and hosts behaves like a single network.

## VLANs

VLAN is a networking technology that enables a single switch to act ass if it was multiple independent switches. Specially, two hosts that are connected to the same switch but on differnet VLANs do not see each others traffic. OpenStack is able to take advantages of VLANs to isolate the traffic of different projects, even if the projects happen to have instances running on the same compute host. Each VLAN has an associated numerical ID, between 1 and 4094. We say VLAN 15 to refer to the VLAN with a numerical ID of 15. 

To understand how VLANs work, lets consider VLAN applications in a traditional IT environment, where physical hosts are attached to a physical switch, and no virtualization is involved. Imagine a scenario where you want three isolated networks but you only have a single physical network switch. The network administrator would choose three VLAN IDs, for example 10, 11 and 12, and would configure the switch to associate switchports with VLAN IDs. For example, switchport 2 might be associated with VLAN 10, switchport 3 might be associated with VLAN 11, and so forth. When a switchport is configured for a specific VLAN, it is called an access port. The switch is responsible for ensuring that the network traffic is isolated across the VLANs.

Now consider the scenario that all of the switchports in the first switch become occupies, and so the organization buys a second switch and connects it to the first switch to expand the available number of switchports. The second switch is also configured to support VLAN IDs 10, 11, and 122. Now imagine host A connected to switch 1 on a port configured for VLAN ID 10 sends an Ethernet frame intended for host B connect to switch 2 on a port configured for VLAN ID 10. When switch 1 forwards the Ethernet frame to switch 2, it must communicate that the frame is associated with VLAN ID 10.

If two switches are to be connected together, and the switches are configured for VLANs, then the switchports used for cross-connecting the switches must be configured to allow Ethernet frames from any VLAN to be forwared to the other switch. In addition, the sending switch must tag each Ethernet frame with the VLAN ID so that the receiving switch can ensure that only hosts on the matching VLAN are eligible to receive the frame.

A switchport that is configured to pass frames from all VLANs and tag them with the VLAN IDs is called a trunk port. IEEE 802.1Q is the network standard that describes how VLAN tags are encoded in Ethernet frames when trunking is being used.

Note that if you are using VLANs on your physical switches to implement project isolation in your OpenStack cloud, you must ensure that all of your switchports are configured as trunk port.

It is important that you select a VLAN range not being used by your current network infrastructure. For example, if you estimate that your cloud must support a maximum of 100 projects, pick a VLAN range outside of that value, such as VLAN 200299. OpenStack, and all physical network infrastructure that handles project networks, must then support this VLAN range.

Trunking is used to connect between different switches. Each trunk uses a tag to identify which VLAN is in use. This ensure that switches on the same VLAN can communicate.

TODO: read again

## Subnets and ARP

While NICs use MAC address to address network hosts, TCP/IP applications use IP addresses. The Address Resolution Protocol (ARP) bridges the gap between Ethernet and IP by translating IP addresses into MAC addresses.

IP addresses are broken up into two parts: a network number and a host identifier. Two hosts are on the same subnet if they have the same network number. Recall that two hosts can only communicate directly over Ethernet if they are on the same local network. Network administrators must take care when assigning IP addresses and netmarks to hosts so that any two hosts that are in the same subnet are on the same local network, otherwise ARP does not work properly.

To caculate the network number of an IP address, you must know the netmarks associated with the address. A netmask indicates how many the bits in the 32-bit IP address make up the network number.

There are two syntaxes for expressing a netmask:

- dotted quad
- classless inter-domain routing (CIDR)

Sometimes we want to refer to a subnet, but not any particular IP address on the subnet. A common convention is to set the host identifier to all zeros to make reference to a subnet. For example, if a hosts IP address is 192.0.2.24/24, the we would say the subnet is 192.0.2.0/24.

To understand how ARP translates IP address to MAC addresses, consider the following example. Assume host A has an IP address of 192.0.2.5/24 and a MAC address of fc:99:47:49:d4:a0, and wants to send a packet to host B with an IP address of 192.0.2.7. Note that the network number is the same for both hosts, so host A is able to send frames directly to host B.

The first time host A attempts to communicate with host B, the destination MAC address is not known. Host A makes an ARP request to the local network. The request is a broadcast with a message like this:

To: every body (ff:ff:ff:ff:ff:ff). I am looking for the computer who has IP address 192.0.2.7. Signed: MAC address: fc:99:47:49:d4:a0.

Host B responses with a response like this:

To: fc:99:47:49:d4:a0. I have IP address 192.0.2.7. Signed: MAC address 54:78:1a:86:00:a5.

Host A then sends Ethernet frames to host B.

## DHCP

Hosts connected to a network use the Dynamic Host Configuration Protocol (DHCP) to dynamically obtain IP addresses. A DHCP server hands out the IP addresses to network hosts, which are the DHCP clients.

DHCP clients locate the DHCP server by sending a UDP packet from port 68 to address 255.255.255.255 on port 67. Address 255.255.255.255 is the local network broadcast address: all hosts on the local network see the UDP packets sent to this address. However, such packets are not forwarded to other networks. Consequent ly, the DHCP server must be on the same local network as the client, or the server will not receive the broadcast. The DHCP server responds by sending a UDP packet from port 67 to port 68 on the client.  

1. The client sends a discover (Im a client at MAC address 08:00:27:b9:88:74, I need an IP address)

2. The server sends an offer (OK 08:00:27:b9:88:74, Im offering IP address 192.0.2.112)

3. The client sends a request (Server 192.0.2.131, I would like to have IP 192.0.2.112)

4. The server sends an ack (OK 08:00:27:b9:88:74, IP 192.0.2.112 is yours)

OpenStack uses a third-party program called dnsmasq to implement the DHCP server. Dnsmasq writes to the syslog, where you can observe the DHCP request and replies

## IP

The Internet Protocol (IP) specifies how to route packets between hosts that are connected to different local networks. IP relies on special network hosts called routers or gateway. A router is a host that is connected to at least two local networks and can forward IP packets IP from one local network to another.

A router has multiple IP address: one for each of the networks it is connected to.

In the OSI model of networking protocols IP occupies the third layer, known as the network layer. When dicussing IP, you will often hear terms such as layer 3, L3, and network layer.

A host sending a packet to an IP address consults its routing table to determine which machine on the local network(s) the packet should be sent to. The routing table maintains a list of the subnets associated with each local network that the host is directly connected to, as well as a list of routers that are on these local networks.

## TCP/UDP/ICMP

For networked software applications to communicate over an IP network, they must use a protocol layered atop IP. These protocols occupy the fourth layer of the OSI model known as the transport layer or layer 4.

The Transmission Control Protocol (TCP) is the most commonly used layer 4 protocol in networked applications. TCP is a connection-oriented protocol: it uses a client-server model where a client connects to a server, where server refers to the application that receives connections. The typical interaction in a TCP-based application proceeds as follows:

1. Client connects to server.
2. Client and server exchange data.
3. Client or server disconnects.

Because a network host may have multiple TCP-based application running, TCP uses an addressing scheme called pors to uniquely identify TCP-based applications. A TCP port is associated with a number in the range 1-65535, and only one application on a host can be associated with a TCP port at a time, a restriction that is enforced by the operating system.

A TCP server is said to listen on a port. For example, an SSH server typically listens on port 222. For a client to connect to a server using TCP, the client must know both the IP address of a servers host and the server TCP port.

The os of the TCP client application automatically assigns a port number to the client. The client owns this port number until the TCP connection is terminated, after which the os reclaims the port number. These types of ports are referred to as ephemeral ports.

The most common application programming interface (API) for writing TCP-based applications is called Berkely sockets, also known as BSD sockets or, simply, sockets. The sockets API exposes a stream oriented interface for writing TCP applications. Sending data over a TCP connection is similar to writing a stream of bytes to a file. It is the responsibility of the os TCP/IP implementation to break up the stream of data into IP packets. The operating system is also reponsible for automatically retrasmitting dropped packets, and for handling flow control to ensure that transmitted data does not overrun the senders data buffers, receivers data buffers and network capacity.

DHCP, the DNS, VXLAN are examples of UDP-based protocols used in OpenStack deployments. 

UDP has support for one-to-many communication: sending a single packet to multiple hosts. An application can broadcast a UDP packet to all of the network hosts on a local network by setting the receiver IP address as the special IP broadcast address 255.255.255.255.  An application can also send a UDP packet to a set of receivers using IP multicast. The intended receiver applications join a multicast group by binding a UDP socket to special IP address that is one of the valid multicast group addresses. The receiving hosts do not have to be on the same local network .. VXLAN is an exmaple of a UDP-based protocol that uses IP multicast.

The Internet Control Message Protocol (ICMP) is a protocol used for sending control messages over an IP network. For example, a router that receives an IP packet may send an ICMP packet back to the source if there is no route in the routers routing table that corresponds to the destination address (ICMP code 1, destination host unreachable) or if the IP packet is too large for the router to handle (ICMP code 4, fragmentation required and dont fragment flag is set).

The ping and mtr Linux command-line tools are two examples of network utilities that use ICMP.

## Switches

Switches are Multi-Input Multi-Output (MIMO) devices that enable packets to travel from one node to nother. Switches connect hosts that belong to the same layer-2 network. Switches enable forwarding of the packet received on one port (input) to another port (output) so that they reach the destination node. They forward the traffic based on the destination Ethernet address in the packet header.

## Routers

Routers are special devices that enable packets to travel from one layer-3 network to another. Routers enable communication between two nodes on different layer-3 networks that are not directly connected to each other. Routers operate at layer-3 in the networking model. They route the traffic based on the destination IP address in the packet header.

## Firewalls

Firewalls are used to regulate traffic to and from a host or a network. A firewall can be either a specialized device conneccting two networks or a software-based filtering mechanism implemented on on os. Firewall are used to restrict traffic to a host based on the rules defined on the host. They can filter packets based on several criteria such as source IP address, destination IP address, port numbers, connection state, and so on.

## Load balancers

Load balancers can be software-based or hardware-based devices that allow traffic to evenly be distributed across several servers. By distributing the traffic across multiple servers, it avoids overload of a single server thereby preventing a single point of failure in the product. This further improves the performance, ...

## Overlay (tunnel) protocols

Tunneling is a mechanism that makes trasfer of payloads feasible over an incompatible delivery network. It allows the network user to gain access to denied or insecure networks.

## Generic routing encapsulation (GRE)

## Virtual extensible local area network (VXLAN)

The purpose of VXLAN is to provide scalable network isolation. VXLAN is a Layer 2 overlay scheme on a Layer 3 network. It allows an overlay layer-2 network to spread across multiple underlay layer-3 network domains. Each overlay is termed a VXLAN segment. Only VMs within the same VXLAN segment can communicate.

## Generic Network Virtualization Encapsulation (GENEVE)

## Network Address Translation

Network Address Translation (NAT) is a process for modifying the source or destination addresses in the headers of an IP packet while the packet is in transit. In general, the sender and receiver applications are not aware the IP packets are benig manipulated.

NAT is often implemented by routers, and so we will refer to the host performing NAT as a NAT router. However, in OpenStack deployments it is typically Linux servers that implement the NAT functionality, not hardware routers. These servers use the iptables software package to implement the NAT functionality.

There are multiple variations of NAT.

### SNAT

In Source Network Address Translation (SNAT), the NAT router modifies the IP address of the sender in IP packets. SNAT is commonly used to enable hosts with private addresses to communicate with servers on the public Internet.

RFC 1918 reserves the following three subnets as private addresses:

- 10.0.0.0/8
- 172.16.0.0/12
- 192.168.0.0/16

These IP addresses are not publicly routable, meaning that a host on the public Internet can not send an IP packet to any of these addresses. Private IP addresses are widely used in both residential and corporate environments.

Often, an application running on a host with a private IP address will need to connect to a server on the public Internet. An example is a user who wants to access a public website such as www.openstack.org. If the IP packets reach the web server at www.openstack.org with a private IP address as the source, then the web server cannot send packets back to the sender.

SNAT solves this problem by modifying the source IP address to an IP address that is routable on the public internet. There are different variations of SNAT; in the form that OpenStack deployments use, a NAT router on the path between the sender and receiver replaces the packets source IP address with the routers public IP address. The router also modifies the source TCP or UDP port to another value, and **the router maintains a record of the senders true IP address and port, as well as the modified IP address and port.**

When the router receives a packet with the matching IP address and port, it translates these back to the private IP address and port, and forwards the packet along.

Because the NAT router modifies portrs as well as IP address, this form of SNAT is sometimes referred to as Port Address Translation (PAT). It is also sometimes referred to as NAT overload.

OpenStack uses SNAT to enable applications running inside of instances to connect out to the public Internet.

### DNAT

In Destination Network Address Translation (DNAT), the NAT router modifies the IP address of the destination in IP packet headers.

OpenStack users DNAT to route packets from instances to the OpenStack metadata service. Applications running inside of instances access the OpenStack metadata service by making HTTP GET requests to a web server with IP address 169.254.169.254. In an OpenStack deployment, there is no host with this IP address. Instead, OpenStack uses DNAT to change the destination IP of these packets so they reach the internet that a metadata service is listening on.

## OpenStack Networking

OpenStack Networking allows you to create and manage network objects, such as networks, subnets, and ports, which other OpenStack services can use.

### Provider networks

Applications that run inside the OpenStack deployment might require direct layer-2 access, typically using VLANs, to applications outside of the deployment.

### Routed provider networks

### Self-service networks

Self-service networks use overlay protocols such as VXLAN or GRE because they can support many more networks that layer-2 segmentation using VLAN tagging. Furthermost VLANs typically require addition configuration of physical network infrastructure.

**Flat**

All instances reside on the same network, which can also be shared with the hosts. No VLAN tagging or other network segregation takes place.

**VLAN**

Networking allows users to create multiple provider or project networks using VLAN IDs (802.1Q tagged) that corresponds to VLANs present in the physical network. This allows instances to communicate with each toher across the environment. The can also communicate with dedicated servers, firewalls, and other networking infrastructure on the same layer 2 VLAN. 

**GRE and VXLAN**

VXLAN and GRE are encapsulation protocols that create overlay networks to activate and control communication between compute instances. A Networking router is required to allow traffic to flow outside of the GRE or VXLAN project network. A router is also required to connect directly connected project networks with external networks, include the Internet. The router provides the ability to connect to instances directly from an external network using floating IP addresses.

### Subnets

A block of IP addresses and associated configuration state.

### Subnet pools

End users normally can create subnets with any valid IP addresses without other restrictions. However, in some cases, it is nice for the admin or the project to pre-define a pool of addresses from which to create subnets with automatic allocation.

Using subnet pools constrains that addresses can be used by requiring that every subnet be within the defined pool. It also prevents address reuse or overlap by two subnets from the same pool.


