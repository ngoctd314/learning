# Introduction to the ACME Registration Service

We will look at some examples of the problems that we can fix by applying dependency injection (DI).

The following topics will be covered in this chapter

- Goals for our system
- Introduction to our system
- Known issues

## Goals for our system

Have you ever tried to grow your own vegetables from seed? It's a long, slow, but gratifying experience. Building great code is no different. In gardening, it's perhaps more common to skip the first step and buy plants as seedlings from the nursery, and programming is much the same. Most of the time, when we join a project, the code already exists; sometimes it's happy and healthy, but often it's sick and dying.

In this situation, we are adopting a system. It works, but has a few thorns - OK, maybe more than a few. With some tender loving care, we will turn this system into something healthy and thriving.

So, how do we define a healthy system? The system we have works; it does what the business needs it to do. That's enough, right?

Absolutely not! We might explicitly be paid to deliver a certain amount of features, but we are implicitly paid to provide code that can be maintained and extended. Beyond considering why we are paid, let's take a more selfish view: do you want your work tomorrow to be easier or harder than it is today?

A healthy code base has the following key features:

- High readability
- High testability
- Low coupling

**High testability**

Writing automated tests can feel like extra work, something that takes time away from our real purpose of writing features. The primary goal of automated tests is to ensure that code performs as expected, and continues to do so despite any changes or additions we might make to the code base as a whole. Automated tests do, however, have a cost: you have to write and maintain them. Therefore, if your code is easy to test, we will be less inclined to skimp on the tests and rush on to that exciting next feature.

```go
func longMethod(resp http.ResponseWriter, req *http.Request) {
    err := req.ParseForm()
    if err != nil {
        resp.WriteHeader(http.StatusPreconditionFailed)
        return
    }
    userID, err := strconv.ParseInt(req.Form.Get("UserID"), 10, 64)
    if err != nil {
        resp.WriteHeader(http.StatusPreconditionFailed)
        return
    }
    row := DB.QueryRow("SELECT * FROM users WHERE userID = ?", userID)

    person := &Person{}
    err = row.Scan(person.ID, person.Name, person.Phone)
    if err != nil {
        resp.WriteHeader(http.StatusInternalServerError)
        return
    }

    encoder := json.NewEncoder(resp)
    err = encoder.Encode(person)
    if err != nil {
        resp.WriteHeader(http.StatusInternalServerError)
        return
    }
}
```

That code knows too much, it makes me know too much.

It contains boundary-layer (HTTP and database) logic, and it also contains business logic. It is rather long, meaning that I have to keep more context in my head. It's basically one massive violation of the SRP. There are many reasons it could change. The input format could change. The database format could change. The business rules could change. Any such change would mean that every test for this code would likely also need to change.

```go
func TestLongMethod_happyPath(t *testing.T) {
    // build request
    request := &http.Request{}
    request.PostForm = url.Values{}
    request.PostForm.Add("userID", "123")

    // mock the database
    var mockDB sqlmock.Sqlmock
    var err error

    DB, mockDB, err = sqlmock.New()
    require.NoError(t, err)

    mockDB
        .ExpectQuery("SELECT * FROM people WHERE ID = ?")
        .WithArgs(123)
        .WillReturnRows(sqlmock.NewRows([]string{"ID", "Name", "Phone"}))
        .AddRow(123, "May", "0123456789")

    // build response
    response := httptest.NewRecorder()

    // call method
    longMethod(response, request)

    // validate response
    require.Equal(t, http.StatusOK, response.Code)

    // validate the JSON
    responseBytes, err := ioutil.ReadAll(response.Body)
    require.NoError(t, err)

    expectedJSON := `{"ID":123, "Name":"May", "Phone":"0123456789"}` + "\n"
    assert.Equal(t, expectedJSON, string(responseBytes))
}
```

Fix

```go
func shortMethods(resp http.ResponseWriter, req *http.Request) {
    userID, err := extractUserID(req)
    if err != nil {
        resp.WriteHeader(http.StatusInternalServerError)
        return
    }
    person, err := loadPerson(userID)
    if err != nil {
        resp.WriteHeader(http.StatusInternalServerError)
        return
    }

    outputPerson(resp, person)
}

func extractUserID(req *http.Request) (int64, error) {
    err := req.ParseForm()
    if err != nil {
        return 0, err
    }

    return strconv.ParseInt(req.Form.Get("UserID"), 10, 64)
}

func loadPerson(userID int64) (*Person, error) {
    row := DB.QueryRow("SELECT * FROM people WHERE ID = ?", userID)

    person := &Person{}
    err := row.Scan(&person.ID, &person.Name, &person.Phone)
    if err != nil {
        return nil, err
    }
    return person, nil
}

func outputPerson(resp http.ResponseWriter, person *Person) {
    encoder := json.NewEncoder(resp)
    err := encoder.Encode(person)
    if err != nil {
        resp.WriteHeader(http.StatusInternalServerError)
        return
    }
}
```

**Low coupling**
Coupling is a measure of how an object or package relates to others. An object is considered to have high coupling if changes to it will likely result in changes to other objects. When an objec has low coupling, it is independent of other objects of packages. In Go, lwo coupling is best achived through implicit interfaces and stable and minimal exported APIs.

### Final thoughts on goals

All of these goals will lead to code that is easy to read, understand, test and extend - that is to say, code that is maintainable. While these may seem like selfish or perfectionist goals, I would argue that it is imperative for the business in the long term. In short term, delivering value to the users, typically in the form of features, is essential. But when this is done poorly, the rate at which features can be added, the number of programmers required to add features, and the number of bugs that are introduced because of changes will all increase and cost the business more than the cost of developing good code.

## Introduction to our system

Welcome to the project! So what do you need to know to join the team? The first thing you want to know is what it does, its user, and the business environment in which it is deployed.

The system we are working on is an HTTP-based event registration service. It is designed to be called by our web application or native mobile applications.

- Register: This will create a new registration record
- Get: This will return the full details of an existing registration record
- List: This will return a list of all the registrations

### Software architecture

## Known issues

## Summary
