# Just-in-Time Dependency Injection

With traditional dependency injection (DI) methods, the parent or calling object supplies the dependencies to the child class. However, there are many cases where the dependencies have a single implementation. In these cases, a pragmatic approach would be to ask yourself, why inject the dependency at all?

Just-in-Time dependency injection, a strategy that gives us many of benefits of DI, like decoupling and testability, without adding parameters to our constructors or methods.

## JIT injection

```go
type Person struct{}

type DataSource interface {
	Load(int) (Person, error)
}

type MyLoadPersonLogic struct {
	dataSource DataSource
}

func NewLoadPersonLogic(dataSource DataSource) *MyLoadPersonLogic {
	return &MyLoadPersonLogic{dataSource: dataSource}
}

func (m *MyLoadPersonLogic) Load(id int) (Person, error) {
	return m.dataSource.Load(id)
}
```

These kinds of things can feel like unnecessary extra work, and they definitely degrade the UX of the code.
