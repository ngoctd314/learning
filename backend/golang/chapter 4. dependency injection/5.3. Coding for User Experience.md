# Coding for User Experience

Testing, user experience, and dependency graphs. 

The following topics will be covered in this chapter:

- Optimizing for humans
- A security blanket named unit tests
- Test-included damage

## Optimizing for humans

UX typically refers to customers, which make sense - that is, after all, where the money is. However, we programmers are missing out on something rather significant. Let me ask you, who are the users of the code you write? Not the customers that use the software itself. The users of the code are your colleagues and the future version of you. As programmers, we get paid to deliver features rather than beautiful code, and code with good UX enables the faster delivery of features, and with less risk.

## What does user experience mean for Go code

What does UX mean for Go code? The short version is, we should write code whose general intent is understood after a quick first read by any competent programmer.

**1. Start with simple - get complicated only when you must**

We should strive to keep things simple, and resort to complexity when there is no other way.

```go
func NotSoSimple(id int64, name string, age int, registered bool) string {
    out := &bytes.Buffer{}
    out.WriteString(strconv.FormatInt(id, 10))
    out.WriteString("-")
    out.WriteString(strings.Replace(name, " ", "_", -1))
    out.WriteString("-")
    out.WriteString(strconv.Itoa(age))
    out.WriteString("-")
    out.WriteString(strconv.FormatBool(registered))

    return out.String()
}
```

How about this one:

```go
func Simpler(id int64, name string, age int, registered bool) string {
    nameWithNoSpaces := strings.Replace(name, " ", "_", -1)
    return fmt.Sprintf("%d-%s-%d-%t", id, nameWithNoSpaces, age, registered)
}
```

Applying the approach embodied in the first code to an entire system will almost certainly make it run faster, but not only did it likely take longer to code, but it's also harder to read and therefore maintain and extend.

There will be times when you need extract extreme performance from your code, but it's far better to wait until it cannot be avoided before burdening yourself with the extra complexity.

**2. Apply just enough abstraction**

```go
type myGetter interface {
    Get(url string) (*http.Response, error)
}

func TooAbstract(getter myGetter, url string) ([]byte, error) {
    resp, err := getter.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    return ioutil.ReadAll(resp.Body)
}
```

Compare to the previous code

```go
func CommonConcept(url string) ([]byte, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    return ioutil.ReadAll(resp.Body)
}
```

**3. Follow industry, team, and language conventions**