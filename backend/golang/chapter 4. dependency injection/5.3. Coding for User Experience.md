# Coding for User Experience

Testing, user experience, and dependency graphs. 

The following topics will be covered in this chapter:

- Optimizing for humans
- A security blanket named unit tests
- Test-included damage

## Optimizing for humans

UX typically refers to customers, which make sense - that is, after all, where the money is. However, we programmers are missing out on something rather significant. Let me ask you, who are the users of the code you write? Not the customers that use the software itself. The users of the code are your colleagues and the future version of you. As programmers, we get paid to deliver features rather than beautiful code, and code with good UX enables the faster delivery of features, and with less risk.

## What does user experience mean for Go code

What does UX mean for Go code? The short version is, we should write code whose general intent is understood after a quick first read by any competent programmer.

**1. Start with simple - get complicated only when you must**

We should strive to keep things simple, and resort to complexity when there is no other way.

```go
func NotSoSimple(id int64, name string, age int, registered bool) string {
    out := &bytes.Buffer{}
    out.WriteString(strconv.FormatInt(id, 10))
    out.WriteString("-")
    out.WriteString(strings.Replace(name, " ", "_", -1))
    out.WriteString("-")
    out.WriteString(strconv.Itoa(age))
    out.WriteString("-")
    out.WriteString(strconv.FormatBool(registered))

    return out.String()
}
```

How about this one:

```go
func Simpler(id int64, name string, age int, registered bool) string {
    nameWithNoSpaces := strings.Replace(name, " ", "_", -1)
    return fmt.Sprintf("%d-%s-%d-%t", id, nameWithNoSpaces, age, registered)
}
```

Applying the approach embodied in the first code to an entire system will almost certainly make it run faster, but not only did it likely take longer to code, but it's also harder to read and therefore maintain and extend.

There will be times when you need extract extreme performance from your code, but it's far better to wait until it cannot be avoided before burdening yourself with the extra complexity.

**2. Apply just enough abstraction**

```go
type myGetter interface {
    Get(url string) (*http.Response, error)
}

func TooAbstract(getter myGetter, url string) ([]byte, error) {
    resp, err := getter.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    return ioutil.ReadAll(resp.Body)
}
```

Compare to the previous code

```go
func CommonConcept(url string) ([]byte, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    return ioutil.ReadAll(resp.Body)
}
```

**3. Follow industry, team, and language conventions**

Go comment: https://github.com/golang/go/wiki/CodeReviewComments

**4. Export only what you must**

It becomes easier for others to understand; when a method has fewer parameters, it is natually easier to understand.

```go
NewPet("Fido", true)
```

What does true mean? It's hard to tell without opening the function or the document. However
However, what if we do the following:

```go
NewDog("Fido")
```

In this case, the purpose is clear, mistakes are unlikely and, as a bonus, encapsulation is improved.

Similarly, interfaces and structs with fewer methods and packages with objects are all easier to understand, and are more likely to have a more definite purpose.

```go
type WideFormatter interface{
    ToCSV(pets []Pet) ([]byte, error)
    ToGOB(pets []Pet) ([]byte, error)
    ToJSON(pets []Pet) ([]byte, error)
}
```

Compare the preceding code to the following:

```go
type ThinFormatter interface {
    Format(pets []Pet) ([]byte, error)
}

type CSVFormatter struct {}

func (f CSVFormatter) Format(pets []Pet) ([]byte, error) {}
```

## Aggressively apply the single responsibility principle

Applying the single responsibility principle (SRP) encourages objects to be more concise and mor coherent and there fore easier to understand.

## Discovering a good user experience

Ask yourself the following four questions:

- Who is the user?
- What are your users capable of?
- Why do users want to use your code?
- How do your users expect to use it.

### Who is the user?

Much of the time, the answer will be future me and my colleagues. Your future me will be a better, smarter, and more handsome version of who you are now. Your colleagues, on the other hand, are harder to predict. What ever we do, they will understand. An intern, on the other hand, will be harder to predict. Chances are that if we can make our code make sense to them, then it will be just fine for everyone else. 

### What are your users capable of?



### Why do users want to use your code?

### How do they expect to use it?

## 