# Dependency Injection with Monkey Patching

Do you have code that relies on global variable? Do you have code that is dependent on the filesystem? Have you ever tried to test your database error handling code?

Monkey patching as a way to swap out dependencies during our tests and test in a manner that is otherwise impossible. It doesn't matter if these dependencies are objects or functions.

## Technical requirements

## Monkey magic!

Monkey patching is changing a program at runtime, typically by replacing a function or variable.

While this is not a traditional form of DI, it can be used in Go to facilitate testing. In fact, monkey patching can be used to test in ways that are otherwise impossible.

## Advantages of monkey patching

Monkey patching as a form of DI is very different from the other methods presented in this book in both implementation and affect. As such, there are some situations in which monky patching is either the only option or the only succinct.

**DI via monkey patching is cheap to implement**

In this book, we have talked a lot about decoupling, which is the idea that separate pieces of our code should be kept separate, even though they use/depend on each other. We introduce abstractions and inject them into each other.

Consider this function

```go 
func SaveConfig(filename string, cfg *Config) error {
    // convert to JSON
    data, err := json.Marshal(cfg)
    if err != nil {
        return err
    }

    // save file
    err = ioutil.WriteFile(filename, data, 0666)
    if err != nil {
        return err
    }

    return nil
}
```

How do we decouple this function from the os? How do we test how this function behaves when the file is missing?

We could replace the filename with *os.File or io.Writer, but that just pushes the problem somewhere else. We could refactor this function into a struct, change the call to ioutil.WriteFile into an abstraction, and then mock it. But that sounds like a lot of work.

With monkey patching, there is a fer cheaper option:

```go
func SaveConfig(filename string, cfg *Config) error {
    // conver to JSON
    data, err := json.Marshal(cfg)
    if err != nil {
        return err
    }

    // save file
    err = writeFile(filename, data, 0666)
    if err != nil {
        return err
    }

    return nil
}
// Custom type that allows us to Monkey Patch
var writeFile = ioutil.WriteFile
```

With one line, we have given ourselves the ability to replace writeFile() with a mock. That will allow us to test both happy path and error scenarios with ease.

**Allows us to mock other packages, without fully understanding its internals**

Monkey patching, like other forms of mocking, offers us the ability to not care about the internals of the dependency and yet be able to get it to behave as we need it to.

**DI via monkey patching has minimal impact on existing code**

**DI via monkey patching allows testing of globals and singletons**

```go
func Test(t *testing.T) {
    // monkey patching
    defer func(original *Rand) {
        // restore patch after use
        globalRand = original
    }(globalRand)

    // Swap out for a predictable outcome
    globalRand = New(&stubSource{})
    // end monkey patch

    // call the function
    result = Int()
    assert.Equal(t, 234, result)
}

// this is a stubbed implementation of Source that returns a predictable value
type stubSource struct {
}

func (s *stubSource) Int63() int64 {
    return 234
}
```

With monkey patching, we are able to test the usage of the singleton without any changes to the client code. To achieve this with other methods, we would have to introduce a layer of indirection, which in turn would necessitate changes to the client code.

## Applying monkey patching

One one the many things we would like to improve with our service is the test reliability and coverange. In this case, we will working on the data package.

```go
func TestData_happyPath(t *testing.T) {
    in := &Person{
        FullName: "Jake Blues",
        Phone: "01234",
        Currency: "AUD",
        Price: 123.45,
    }

    // save
    resultID, err := Save(in)
    require.Nil(t, err)

    // load
    returned, err := Load(resultID)
    require.NoError(t, err)

    all, err := LoadAll()
    require.NoError(t, err)
    assert.True(t, len(all) > 0)
}
```

This code has at least three major issues.

Firstly, we are only testing the happy path; we have not tested our error handling at all.

Secondly, the relies on the database. Some people will argue this is fine, and I do not want to add to that debate.

Lastly, we are testing all the functions together, rather than in isolation.

All of functions in the data packge depend on a global instance of *sql.DB, which represents a pool of a database connections. We therefore will be monkey patching that global variable and introducing a mocked version.

## Introducing SQL Mock

A mock library implementing sql/driver. Which has one and only purpose - to simulate any sql driver behavior in tests, without needing a real database connection.

```go
func SavePerson(db *sql.DB, in *Person) (int, error) {
    // person DB insert
    query := "INSERT INTO person (fullname, phone, currency, price) VALUES (?, ?, ?, ?)"
    result, err := db.Exec(query, in.FullName, in.Phone, in.Currency, in.Price)
    if err != nil {
        return 0, err
    }

    id, err := result.LastInsertId()
    if err != nil {
        return 0, err
    }

    return int(id), nil
}
```

This function is using a traditional form of DI to pass the database connection pool into the function. This allows us an easy way swap out the read database connection with a fake one.

```go
testDB, dbMock, err := slqmock.New()
require.NoError(t, err)
```

## Monkey patching with SQLMock

```go
func Save(in *Person) (int, error) {
	db, err := getDB()
	if err != nil {
		logging.L.Error("failed to get DB connection. err: %s", err)
		return defaultPersonID, err
	}

	// perform db insert
	query := "INSERT INTO person (fullname, phone, currency, price) VALUES (?, ?, ?, ?)"
	result, err := db.Exec(query, in.FullName, in.Phone, in.Currency, in.Price)
	if err != nil {
		logging.L.Error("failed to save person into DB. err: %s", err)
		return defaultPersonID, err
	}

	// retrieve and return the ID of the person created
	id, err := result.LastInsertId()
	if err != nil {
		logging.L.Error("failed to retrieve id of last saved person. err: %s", err)
		return defaultPersonID, err
	}

	return int(id), nil
}
```

We could refactor to this, and perhaps in the future we might, but at the moment we have almost no tests on this code and refactoring without tests is a terrible idea.  You might be thinking something similar to but if we write tests with monkey patching and then refactor to a different style of DI later, then we have to refactor these tests, and you are right.

```go
func TestSave_happyPath(t *testing.T) {
	// define a mock db
	testDB, mockDB, err := sqlmock.New()
	require.NoError(t, err)

	queryRegex := convertSQLToRegex(sqlInsert)
	mockDB.ExpectExec(queryRegex).WillReturnResult(sqlmock.NewResult(2, 1))

	// monkey patching starts here
	defer func(originalDB *sql.DB) {
		db = originalDB
	}(db)
	// replace db for this test
	db = testDB
	// end of monkey patching

	in := &Person{
		FullName: "NgocTD",
		Phone:    "01234",
		Currency: "AUD",
		Price:    123.45,
	}

	resultID, err := Save(in)
	require.NoError(t, err)
	assert.Equal(t, 2, resultID)
}
```

## Testing error handling

There are three possible errors we need to handle

- The SQL insert could fail
- Failure to get the database
- We could fail to retrieve the ID of the inserted record