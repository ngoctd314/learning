# Strategy pattern

Problem: You has a task to counting number of sms or email in a day. You already have sms table look like this

|id|channel|status|template_id|
|-|-|-|-|
|1|sms|success|template_id1|
|2|email|failed|template_id2|
|3|sms|unknow|template_id2|
|4|email|waiting|template_id1|


```go
// problem
// if business use another notifier type 
// we must modification old code
// impact:
// modify code => violate open / close principle
// modify test case 
// maybe create two many ifelse logic
// violate single responsibility
type notifierType string

const (
	emailNotifier notifierType = "email"
	smsNotifier   notifierType = "sms"
)

type notificationService struct {
	notifierType notifierType
}

func (s notificationService) sendNotification(message string) {
	switch s.notifierType {
	case emailNotifier:
		// Do send email logic
		fmt.Printf("Sending message: %s (Sender: %s)\n", message, s.notifierType)
	case smsNotifier:
		// Do send sms logic
		fmt.Printf("Sending message: %s (Sender: %s)\n", message, s.notifierType)
	}
}

func main() {
	s := notificationService{emailNotifier}
	s.sendNotification("Hello World")
}
```

```go
type Notifier interface {
	Send(msg string)
}
type notificationService struct {
	notifier Notifier
}

type EmailNotifier struct {
	notifierType string
}

func (n EmailNotifier) Send(msg string) {
	// Do send email logic
	fmt.Printf("Sending message: %s (Sender: %s)\n", msg, n.notifierType)
}

type SmsNotifier struct {
	notifierType string
}

func (n SmsNotifier) Send(msg string) {
	// Do send sms logic
	fmt.Printf("Sending message: %s (Sender: %s)\n", msg, n.notifierType)
}

func main() {
	smsNotifier := SmsNotifier{"sms"}
	emailNotifier := EmailNotifier{"email"}
	s := notificationService{smsNotifier}
	s.notifier.Send("Hello World")

	s = notificationService{emailNotifier}
	s.notifier.Send("Hello World")
}
```
