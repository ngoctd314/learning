# Concurrency: Practice

This chapter covers

- Preventing common mistakes with goroutines and channels
- Understanding the impacts of using standard data structures alongside concurrent code
- Using the standard library and some extensions
- Avoiding data races and deadlocks

## Propagating an inappropriate context

Contexts are omnipresent when working with concurrency in Go, and in many situations, it may be recommended to propagate them. However, context  propagation can sometimes lead to subtle bugs, preventing subfunction from being correctly executed.

Let's consider the following example. We expose an HTTP handler that performs some tasks and returns a response. But just before returning the response, we also want to send it to a Kafka topic. We don't want to penalize the HTTP consumer latency-wide, so we want the publish action to be handled asynchronously wihtin a new goroutine. We assume that we have at our disposal a publish function that accepts a context so the action of publishing a message can be interrupted if the context is canceled.

```go
func handler(w http.ResponseWriter, r *http.Request) {
    response, err := doSomeTask(r.Context(), r)
    if err != nil {
        return
    }

    go func() {
        err := publish(r.Context(), response)
    }()

    writeResponse(response)
}
```

We have to know that the context attached to an HTTP request can be cancel in different conditions:

- When the client's connection closes
```go
func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		go func() {
			select {
			case <-ctx.Done():
				fmt.Printf("ctx.Err() %s\n", ctx.Err())
            default:
                publish("msg")
			}
		}()
		time.Sleep(time.Second * 5)

		w.Write([]byte("OK"))
	})
	http.ListenAndServe(":8080", nil)
}
```

- In the case of HTTP/2 request, when the request is canceled.
- When the response has been written back to the client.

```go
func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		go func() {
			select {
			case <-ctx.Done():
				fmt.Printf("ctx.Err() %s\n", ctx.Err())
			}
            default:
                publish("msg")
		}()

		w.Write([]byte("OK"))
	})
	http.ListenAndServe(":8080", nil)
}
```

In the first two cases, we probably handle things correctly. For example, if we get a response from doSomeTask but the client has closed the connection, it's probably OK to call publish with a context already canceled so the message isn't published. But what about the last case?

When the response has been written to the client, the context associated with the request will be canceled. Therefore, we are facing a race condition:

- If the response is written after the Kafka publication, we both return a response and publish a message successfully
- However, if the response is written before or during the Kafka publication, the message shouldn't be published.

In the latter case, calling publish will return an error because we returned the HTTP response quickly.

How can we fix this issue? One idea is to propagate the parent context. Instead, we would call publish with an empty context:

```go
// uses an empty context instead of the HTTP request context
err := publish(context.Background(), response)
```

Here, that would work. Regardless of how long it takes to write back the HTTP response, we can call publish.

But what if the context contained useful values? For example, if the context contained a correlation ID used for distributed tracing, we could correlate the HTTP request and the Kafka publication. Ideally, we would like to have a new context that is detached from the potential parent cancellation but still conveys the values.

The standard package doesn't provide an immediate solution to this problem. Hence, a possible solution is to implement our own Go context similar to the context provided, except that it doesn't carry the cancellation signal.

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key any) any
}
```
The context's deadline is managed by the Deadline method and the Cancellation signal is managed via the Done and Err methods. 

```go
type detactContext struct {
	context.Context
}

func (d detactContext) Deadline() (time.Time, bool) {
	return time.Time{}, false
}

func (d detactContext) Done() <-chan struct{} {
	return nil
}

func (d detactContext) Err() error {
	return nil
}
```

Except for the Value method that calls the parent context to retrieve a value, the other methods return a default value so the context is never consider expired or canceled.

Now the context passed to publish will never expire or be canceled, but it will carry the parent context's values.


