# Strings

In Go, a string is an immutable data structure holding the following:

- A pointer to an immutable byte sequence
- The total number of bytes in this sequence

We will see in this chapter that Go has a pretty unique way to deal with strings. Go introduces a concept called runes; this concept is essential to understand and may confuse newcomers. Once we know how strings are managed, we can avoid common mistakes while iterating on a string.

## 36. Not understanding the concept of a rune

We couldn't start this chapter about strings without discussing the concept of the rune in Go. As you will see in the following sections, this concept is key to thoroughly understanding how strings are handled and avoiding common mistakes. But before delving into Go runes, we need to make sure we are aligned about some fundamental programming concepts.

We should understand the distinction between a charset and and encoding:

- A charset, as the name suggests, is a set of characters. For example, the Unicode charset contains 2^21 characters.
- An encoding is the translation of a character's list in binary. For example, UTF-8 is an encoding standard capable of encoding all the Unicode characters in a variable number of bytes (from 1 to 4 bytes).

We mentioned characters to simplify the charset definition. But in Unicode, we use the concept of a code point to refer to an item represented by a single value.

In Go, a rune is a Unicode code point. Meanwhile, we mentioned that UTF-8 encodes characters into 1 to 4 bytes, hence up to 32 bits. This is why in Go, a rune is an alias of int32.

```go
type rune = int32
```

Another thing to hightlight about UTF-8: some people believe that Go strings are always UTF-8, but this isn't true. Let's consider the following example:

```go
s := "hello"
```

We assign a string literal (a string constant) to s. In Go, a source code is encoded in UTF-8, all string literals are encoded into sequence of bytes using UTF-8. However, a string is a sequence of arbitrary bytes; it's not necessarily based on UTF-8. Hence, when we manipulate a variable that wasn't initialized from a string literal (for example, reading from the filesystem), we can't necessarily assume that it uses the UTF-8 encoding. 

Let's get back to the hello example. We have a string conposed of five characters: h, e, l, l and o.

These simple characters are encoded using a single byte each. This is why getting the length of s return 5:

```go
s := "hello"
fmt.Println(len(s)) // 5
```

But a character isn't always encoded into a single byte. Coming back to the 汉characer, we mentioned that with UTF-8, this character is encoded into three bytes. We can validate this with the following example:

```go
s := "汉"
fmt.Println(len(s)) // 3
```

Instead of printing 1, this example prints 3. Indeed, the len built-in function applided on a string doesn't return the number of characers; it returns the number of bytes.

- A charset is a set of characters, whereas an encoding describes how to translate a charset into binary.
- In Go, a string references an immutable slice of arbitrary bytes.
- A charset is a set of characters, whereas an encoding describes how to translate a charset into binary.
- In Go, a string is references an immutable slice of arbitrary bytes.
- Go source code is encoded using UTF-8. Hence, all string literals are UTF-8 strings. But because a string can contain arbitrary bytes, if it's obtained from somewhere else (not the source code), it isn't guaranteed to be based on the UTF-8 encoding.
- A rune corresponds to the concept of a Unicode code point, meaning an item represented by a single value.
- Using UTF-8, a Unicode code point can be encoded into 1 to 4 bytes.
- Using len on a string in Go returns the number of bytes, not the number of runes.

## 37. Inaccurate string iteration

Iterating on a string is a common operation for developers.

Let's look at a concrete example. Here, we want to print the different runes in a string and their corresponds positions:

```go
s := "hêllo"
for i := range s {
    fmt.Printf("position %d: %c\n", i, s[c])
}
```

```txt
position 0: h
position 1: Ã
position 3: l
position 4: l
position 5: o
len=6
```

This code doesn't do what we want. Let's highlight three points:

- The second rune is Ã in the output instead of ê.
- We jumped from position 1 to position 3: what is at position 2?.
- len returns a count of 6, whereas s contains only 5 runes.

Len returns the number of bytes in a string, not the number of runes. Because we assigned a string literal to s, s is a UTF-8 string. Meanwhile, the special character ê isn't encoded in a single byte; it requires 2 bytes. Therefore, calling len(s) returns 6.

```go
fmt.Println(len([]rune(s)))
fmt.Println(utf8.RuneCountInString(s))
```

When convert a slice of runes using []rune(s). Introduces a run-time overhead compared to the previous one. Indeed, converting a string into a slice of runes requires allocating an additional slice and converting the bytes into runes: an O(n) time complexity with n the number of bytes in the string. Therefore if we want to iterate over all the runes, we should use: 

```go
for i, v := range s {
    fmt.Println(i, v) // v will be rune
}
```

**A possible optimization to access a specific rune**

One optimization is possible if a string is composed of single-byte runes:

