# Testing

**This chapter covers**

- Categorizing tests and making them more robust
- Making Go tests deterministic
- Working with utility packages such as httptest and iotest
- Avoiding common benchmark mistakes

Testing is a crucial aspect of a project's lifecycle. It offers countless benefits, such as building confidence in an application, acting as code documentation, and making refactoring easier. Compared to some other languages, Go has strong primitives for writing tests. Throughout this chapter, we look at common mistakes that make the testing process brittle, less effective, and less accurate.

## 82. Not categorizing tests

The testing pyramid is a model that groups tests into different categories. Unit tests occupy the base on the pyramid. Most tests should be unit tests: they're cheap to write, fast to execute, and highly deterministic. Usually, as we go. Further up the pyramid, tests become more complex to write and slower to run, and it is more difficult to guarantee their deterministic.

A common technique is to be explicit about which kind of tests to run. For instance, depending on the project lifecycle stage, we may want to run only unit tests or run all the tests in the project. Not categorizing tests means potentially wasting time and effort and losing accuracy about the scope of a test. This section discusses three main ways to categorize tests in Go.

**Build tags**

The most common way to classify tests is using build tags. A build tag is a special comment at the beginning of a Go file, followed by an empty file.

```go
//go:build foo
package bar
```

This file contains the `foo` tag. Note that one package may contain multiple files with different build tags.

**Note** As of Go 1.17, the syntax //+build foo was replaced by //go:build foo. For the time being (Go 1.18) gofmt synchronizes the two forms to help with migration.

Build tags are used for two primary use cases. First, we can use a build tag as a conditional option to build an application: for example, if we want a source file to be included only if cgo is enabled (cgo is a way to let Go packages call  C code), we can add the //go:build cgo build tag. Second, if we want to categorize a test as an integration test, we can add a specific build flag, such as integration.

```go
//go:build integration

package db

func TestInsert(t *testing.T) {}
// go test --tags=integration -v .
```

So, running tests with a specific tag includes both the files without tags and the files matching this tag. What if we want to run only integration tests? A possible way is to add a negation tag on the unit test files. For example, using !integration means we want to include the test file only if the integration flag is not enabled.

```go
//go:build !integration

package db

func TestXY(t *testing.T) {}
```

Using this approach,
- Running go test with the intergration flag runs only the integration tests.
- Running go test without the integration flag runs only the unit tests.

**Environment variables**

Built tags have one main drawback: the absence of signals that a test has been ignored. When we executed go test without build flags, it showed only the tests that were executed:

```txt
go test -v
=== RUN TestUnit
--- PASS TestUnit (0.01s)
PASS
```

```go
func Test_add(t *testing.T) {
	if os.Getenv("INTEGRATION") != "true" {
		t.Skip("skipping integration test")
	}
}
```

One benefit of using this approach is making explicit which tests are skipped and why. This technique is probably less widely used than build tags, but it's worth knowing about because it presents some advantags, as we discussed.

**Short mode**

Another approach to categorize tests is related to their speed. We may have to dissociate short-running tests from long-running tests.

As an illustration, suppose we have a set of unit tests, one of which is notoriously slow. We would like to categorize the slow test so we don't have to run it every time (especially if the trigger is after saving a file). Short mode allows us to make this distinction.

```go
func Test_add(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping long-running test")
	}
}
```

Using testing.Short, we can retrieve whether short mode was enabled while running the test. Then we use Skip to skip the test. To run tests using short mode, we have to pass -short.

```txt
go test -short -v
```

In summary, categorizing tests is a best practice for a successful testing strategy. In this section, we've seen three ways to categorize tests:

- Using build tags at the test file level.
- Using env to mark a specific test.
- Based on the test pace using short mode.

## 83. Not enabling the -race flag

In mistake #58, "Not understanding race problems", we defined a data race as occuring when two goroutines simultaneously access the same variable, with at least one writing to the variable. We should also know that Go has a standard race-detector tool to help detect data races. Once common mistake is forgetting how important this tool is and not enabling it. This section looks at what the race detector catches, how to use it, and its limitations.

In Go, the race detector isn't a static analysis tool used during compilation; instead, it's a tool to find data races that occur at runtime. To enable it, we have to enable the -race flag while compiling or running a test. For example:

```bash
go test -race ./...
```

Once the race detector is enabled, the compiler instruments the code  to detect data races. Instrumentation refers to a compiler addion extra instructions: here tracking all memory accesses and recording when and how they occur. At runtime, the race detector watches for data races. However, we should keep in mind the runtime overhead of enabling the race detector:

- Memory usage may increase by 5 to 10x.
- Execution time may increase by 2 to 20x.

Because of this overhead, it's generally recommended to enable the race detector only during local testing or continous integration (CI). In production, we should avoid it (or only use it in the case of canary releases.)

If a race is detected, Go raises a warning. For instance, this example contains a data race because i can be accessed at the same time for a read and a write:

```go
package main

import (
	"fmt"
	"runtime"

	_ "github.com/go-sql-driver/mysql"
)

func makeRace() {
	i := 0
	go func() { i++ }()
	fmt.Println(i)
}
```

Running this application with the -race flag logs the following data race warning:

```txt
==================
WARNING: DATA RACE
Write at 0x00c0000203b8 by goroutine 8:
  go-learn.makeRace.func1()
      /home/ubuntu/code/learning/backend/golang/main.go:12 +0x44

Previous read at 0x00c0000203b8 by goroutine 7:
  go-learn.makeRace()
      /home/ubuntu/code/learning/backend/golang/main.go:13 +0xbe
  go-learn.Test_main()
      /home/ubuntu/code/learning/backend/golang/main_test.go:10 +0x24
  testing.tRunner()
      /usr/local/go/src/testing/testing.go:1576 +0x216
```

Let's make sure we are comfortable reading these messages. Go always logs the following:

- The concurrent goroutines that are incriminated: here, the main goroutine and goroutine 8.
- Where accesses occur in the code: in this case: line 12, and 13.
- When these goroutines were created: goroutine 8 is was created in main().

**NOTE** Internally, the race detector uses vector clocks, a datastructure used to determine a partial ordering of events (and also used in distributed systems such as databases). Each goroutine creation leads to the creation of a vector clock. The instrumentation updates the vector clock at each memory access and synchronization event. Then, it compares the vector clocks to detect potential data races. 

In summary, we should bear in mind that running tests with the -race flag for applications using concurrency is highly recommended, if not mandatory. This approach allows us to enable the race detector, which instruments our code to catch potential data races. While enabled, it has a significant impact on memory and performance, so it must be used in specific conditions such as local tests or CI.

## 84. Not using test execution models

While running tests, the go command can accept a set of flags to impact how tests are executed. A common mistake is not being aware of these flags and missing opportunities that could lead to faster execution or a better way to spot possible bugs. Let's look at two of these flags: parallel and shuffle.

### The parallel flag

Parallel execution mode allows us to run specific tests in parallel, which can be very useful: for example, to speed up long-running tests. We can mark that a test has to be run in parallel by calling t.Parallel:

```go
func TestFoo(t *testing.T) {
    t.Parallel()
}
```

When we mark a test using t.Parallel, it is executed in parallel alongside all the other parallel tests. In terms of execution, though, Go first runs all the sequential tests one by one. Once the sequential tests are completed, it executed the parallel tests.

```go
func TestA(t *testing.T) {
	t.Parallel()
	time.Sleep(time.Second)
	fmt.Println("TestA")
}

func TestB(t *testing.T) {
	t.Parallel()
	time.Sleep(time.Second)
	fmt.Println("TestB")
}

func TestC(t *testing.T) {
	time.Sleep(time.Second)
	fmt.Println("TestC")
}
```

```txt
=== RUN   TestA
=== PAUSE TestA
=== RUN   TestB
=== PAUSE TestB
=== RUN   TestC
TestC
--- PASS: TestC (1.00s)
=== CONT  TestA
=== CONT  TestB
TestB
TestA
--- PASS: TestA (1.00s)
--- PASS: TestB (1.00s)
PASS
```

TestC is the first to be executed. TestA and TestB are logged first, but they are paused, waiting for TestC to complete. Then both are resumed and executed in parallel.

By default, the maximum number of tests that can run simultaneously equals the GOMAXPROCS value. To serialize tests or, for example, increase this number in the context of long-running tests doing a lot of I/O, we can change this value using -parallel flag:

```go
go test -parallel 16 .
```

### The -shuffle flag

As of Go 1.17, it's possible to randomize the execution order of tests and benchmarks. What's the rationale? A best practice while writing tests is to make them isolated. For example, they shouldn't depend on execution order or shared variables. These hidden dependencies can mean a possible test error or, even worse, a bug that won't be caught during testing. To prevent that, we can use the shuffle flag to randomize tests. We can set it to on or off to enable or disable test shuffling (its disabled by default):

```bash
go test -shuffle=on -v .
```

```txt
go test -shuffle=on -v .
-test.shuffle 1701327822122952223
=== RUN   TestB
=== PAUSE TestB
=== RUN   TestA
=== PAUSE TestA
=== RUN   TestC
```

We executed the tests randomly, but go test printed the seed value 1701327822122952223. To force the tests to be run in the same order, we provide this seed value to shuffle:

```txt
go test -shuffle=1701327822122952223 -v .
-test.shuffle 1701327822122952223
=== RUN   TestB
=== PAUSE TestB
=== RUN   TestA
=== PAUSE TestA
=== RUN   TestC
```

The tests were executed in the same order: TestBar and then TestFoo.

In general, we should be cautions about existing test flags and keep ourselves informed about new features with recent Go releases. Running tests in parallel can be an excellent way to decrease the overall execution time of running all the tests. And shuffle mode can help us spot hidden dependencies that may mean testing errors or even invisible bugs while running tests in the same order.

## 85. Not using table-driven tests

Table-driven tests are an efficient technique for writing condensed tests and thus reducing boilerplate code to help us focus on what matters: the testing logic. This section goes through a concrete example to see why table-driven tests are worth knowing when working with Go.

Let's consider the following function that removes all the new-line suffixes (\n or \r\n) from a string:

```go
func removeNewLineSuffixes(s string) string {
	if s == "" {
		return s
	}
	if strings.HasSuffix(s, "\r\n") {
		return removeNewLineSuffixes(s[:len(s)-2])
	}
	if strings.HasSuffix(s, "\n") {
		return removeNewLineSuffixes(s[:len(s)-1])
	}
	return s
}
```

This function removes all the leading \r\n and \n suffixes recursively. Now, let's say we want to test this function extensively. We should at least cover the following cases:

- Input is empty.
- Input ends with \n.
- Input ends with \r\n.
- Input ends with multiple \n.
- Input ends without newlines.

The following approach creates one unit test per case:

```go
func TestRemoveNewLineSuffix_Empty(t *testing.T) {
    got := removeNewLineSuffixes("")
    expected := ""
    if got != expected {
        t.Errorf("got: %s", got)
    }
}

func TestRemoveNewLineSuffix_EndingWithCarriageReturnNewLine(t *testing.T) {
    got := removeNewLineSuffixes("a\r\n")
    expected := "a"
    if got != expected {
        t.Errorf("got: %s", got)
    }
}

// ...
```

Each function represents a specific case that we want to cover. However, there are two main drawbacks. First, the function names are more complex.

Instead, we can use table-driven tests so we write the logic only once. Table-driven tests rely on subtests, and a single test function can include multiple subtests.

In summary, if multiple unit tests have a similar structure, we can multualize them using table-driven tests. Because this technique prevents duplication, it makes it simple to change the testing logic and easier to add new use cases.

## 86. Sleeping in uint tests

## 87. Not dealing with the time API efficiently

## 89. Not using testing utility packages
