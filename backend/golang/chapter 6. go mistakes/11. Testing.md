# Testing

Testing is a crucial aspect of a project's lifecycle. It offers countless benefits, such as building confidence in an application, acting as code documentation, and making refactoring easier. Compared to some other languages, Go has strong primitives for writing tests.

## 82. Not categorizing tests

The testing pyramid is a model that groups tests into different categories. Unit tests occupy the base on the pyramid. Most tests should be unit tests: they're cheap to write, fast to execute, and highly deterministic. Usually, as we go. Further up the pyramid, tests become more complex to write and slower to run, and it is more difficult to guarantee their deterministic.

A common technique is to be explicit about which kind of tests to run. For instance, depending on the project lifecycle stage, we may want to run only unit tests or run all the tests in the project. Not categorizing tests means potentially wasting time and effort and losing accuracy about the scope of a test. 

**Build tags**

The most common way to classify tests is using build tags. A build tag is a special comment at the beginning of a Go file, followed by an empty file.

```go
//go:build foo
package bar
```

**Note** As of Go 1.17, the syntax //+build foo was replaced by //go:build foo. For the time being (Go 1.18) gofmt synchronizes the two forms to help with migration.

Build tags are used for two primary use cases. First, we can use a build tag as a conditional option to build an application: for example, if we want a source file to be included only if cgo is enabled (cgo is a way to let Go packages call  C code), we can add the //go:build cgo build tag. Second, if we want to categorize a test as an integration test, we can add a specific build flag, such as integration.

```go
//go:build integration

package db

func TestInsert(t *testing.T) {}
// go test --tags=integration -v .
```

So, running tests with a specific tag includes both the files without tags and the files matching this tag. What if we want to run only integration tests? A possible way is to add a negation tag on the unit test files. For example, using !integration means we want to include the test file only if the integration flag is not enabled.

```go
//go:build !integration

package db

func TestXY(t *testing.T) {}
```

**Environment variables**

Built tags have one main drawback: the absence of signals that a test has been ignored. When we executed go test without build flags, it showed only the tests that were executed:

```txt
go test -v
=== RUN TestUnit
--- PASS TestUnit (0.01s)
PASS
```

```go
func Test_add(t *testing.T) {
	if os.Getenv("INTEGRATION") != "true" {
		t.Skip("skipping integration test")
	}
}
```

One benefit of using this approach is making explicit which tests are skipped and why. This technique is probably less widely used than build tags, but it's worth knowing about because it presents some advantags, as we discussed.

**Short mode**

Another approach to categorize tests is related to their speed. We may have to dissociate short-running tests from long-running tests.

As an illustration, suppose we have a set of unit tests, one of which is notoriously slow. We would like to categorize the slow test so we don't have to run it every time (especially if the trigger is after saving a file). Short mode allows us to make this distinction.

```go
func Test_add(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping long-running test")
	}
}
```

Using testing.Short, we can retrieve whether short mode was enabled while running the test. Then we use Skip to skip the test. To run tests using short mode, we have to pass -short.

```txt
go test -short -v
```

In summary, categorizing tests is a best practice for a successful testing strategy. In this section, we've seen three ways to categorize tests:

- Using build tags at the test file level.
- Using env to mark a specific test.
- Based on the test pace using short mode.


