# Control structures

## 30. Ignoring the fact that elements are copied in range loops

### Value copy

Understanding how the value is handled during each iteration is critical for using a range loop effectively.

```go
type account struct {
	balance float32
}

func main() {
	accounts := []account{{100}, {200}, {300}}
	for _, ac := range accounts {
		ac.balance += 100
	}
	fmt.Println(accounts)
}
// 100, 200, 300
```

In Go, everything we assign is a copy:

- If we assign the result of a function returning a struct, it performs a copy of that struct.
- If we assign the result of a function returning a pointer, it performs a copy of the memory address (an address is 64 bits long on a 64-bit architecture).

When a range loop iterates over a data structure, it performs a copy of each element to the value variable (the second item)

Coming back to our example, iterating over each account element results in a struct copy being assigned to the value variable a. Therefore, incrementing the balance with ac.balance += 1000 mutates only the value variable (ac), not an element in the slice.

So, what if we want to update the slice elements? There are two main options. The first option is access the element using the slice index. This can be achieved with either a classic for loop or a range loop using the index instead of the value variable:

```go
for i := range accounts {
    accounts[i].balance += 1000
}
for i := 0; i < len(accounts); i++ {
    accounts[i].balance += 1000
}
```

Both iterations have the same effect: updating the elements in the accounts slice.

**Updating slice elements: A third option**

Another option is to keep the range loop and access the value but modify the slice type to a slice of account pointers:

```go
accounts := []*account{{100}, {200}, {300}}

for _, a := range accounts {
    a.balance += 1
}
```

In this case, as we mentioned, the a variable is a copy of the account pointer stored in the slice. But as both pointers reference the same struct, the a.balance += 1 statement updates the slice element.

However, this option has two main downsides. First, it requires updating the slice type, which may not always be possible. Second, it performance is important, we should note that iterating over a slice of pointers may be less efficient for a CPU because of the lack of predictability.

In general, we should remember that the value element in a range loop is a copy. Therefore, if the value is a struct we need to mutate, we will only update the copy, not the element itself, unless the value of field we modify is a pointer. The favored options are to access the element via the index using a range loop or a classic for loop.

## 31. Ignoring how arguments are evaluated in range loops

The range loop syntax requires an expression. For example, in for i, v := range exp, exp is the expression. As we have seen, it can be a string, an array, a pointer to an array, a slice, a map, or a channel. How is this expression evaluated? When using a range loop, this is an essential point to avoid common mistakes.

Do you belive the loop will terminate?
```go
s := []int{1, 2, 3}
for range s { // evaluate s only 1 time
    // manipulation on s
    s = append(s, -1)
}

fmt.Println(s)
```

To understand this question, we should know that when using a range loop, the provided expression is evaluated only once, before the beginning of the loop. In this context, "evaluated" means provided expression is copied to a temporary variable, an then range iterates over this variable.

```go
s := []int{1, 2, 3}
for i := 0; i < len(s); i++ { // len(s) expression is evaludated during each iteration
    s = append(s, -1)
}

fmt.Println(s)
```

```go
s := []int{1, 2, 3}
len := func(s []int) int {
    log.Println("re evaluate")
    return len(s)
}
for i := 0; i < len(s); i++ {
    s = append(s, -1)
}

fmt.Println(s)
```

```go
s := []int{1, 2, 3, 4, 5}
len := func(s []int) int {
    log.Println("re evaluate")
    return len(s)
}
for i := 0; i < len(s); i++ {
    s = []int{1, 2, 3}
}
```

The behavior is different with a classic for loop: The len(s) expression is evaluated during each iteration, and because we keep adding elements, we will never reach a termination state. It's essential to keep this difference in mind to use Go loops accurately.

Coming back to the range operator, we should know that the behavior we described (expression evaludated only once) also applies to all the data types provided.

### Channels

```go
ch1 := make(chan int, 3)
go func() {
    ch1 <- 0
    ch1 <- 1
    ch1 <- 2
    close(ch1)
}()

ch2 := make(chan int, 3)
go func() {
    ch2 <- 10
    ch2 <- 11
    ch2 <- 12
    close(ch2)
}()

ch := ch1
for v := range ch { // range is evaluate only once
    fmt.Println(v)
    ch = ch2
}
```
In this example, the same logic applies regarding how the range expression is evaluated. The expression provided to range is a ch channel pointing to ch1. Hence, range evaluates ch, performs a copy to a temporary variable, and iterates over elements from this channel. Despite the ch = ch2 statement, range keeps iterating over ch1, not ch2:

The ch = ch2 statement isn't without effect, though. Because we assigned ch to the second variable, if we call close(ch) following this code, it will close the second channel, not the first.

### Array

Because the range expression is evaluated is evaluated before the beginning of the loop, what is assigned to the temporary loop variable is a copy of the array.

```go
a := [3]int{0, 1, 2}
for i, v := range a {
    a[2] = 10
    if i == 2 {
        println(v)
    }
}
```

As we mentioned, the range operator creates a copy of the array. Meanwhile, the loop doesn't update the copy; it updates the original array: a. Therefore the value of v during the last iteration is 2, not 10. If we want to print the actual value of the last element, we can do so in two ways:

- By accessing the element from its index:

```go
a := [3]int{0, 1, 2}
for i := range a {
    a[2] = 10
    if i == 2{
        fmt.Println(a[2])
    }
}
```

Because we access the original array, this code prints 2 instead of 10.

- Using an array pointer

```go
a := [3]int{0, 1, 2}
for i, v := range &a {
    a[1] = 10
    if i == 1 {
        println(a[1], v)
    }
}
```

In summary, the range loop evaluates the provided expression only once, before the beginning of the loop, by doing a copy (regardless of the type). We should remember this behavior to avoid common mistakes that might, for example, lead us to access the wrong element.

## 32. Ignoring the impact of using pointer elements in range loops
