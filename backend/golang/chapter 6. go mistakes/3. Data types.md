# Data type

## Creating confusion with octal literals

Go handles binary, hexadecimal, imaginary, and octal numbers. Octal numbers start wiht a 0. However, to improve readability and avoid potential mistakes for future code readers, make octal numbers explicit using 0o prefix.

## Neglecting integer overflows

Not understanding how integer overflows are handled in Go can lead to critical bugs.

### Concepts

### Detecting integer overflow when incrementing

If we want to detect an integer overflow during an increment operation with a type based on a defined size (int8, int16, int32, int64, uint8, uint16, or uint64)

```go
func Inc32(counter int32) int32 {
    if counter == math.MaxInt32 {
        panic("int32 overflow")
    }
    return coutner + 1
}
```

### Detecting integer overflows during addition

```go
func AddInt(a, b int) int {
    if a > math.MaxInt - b {
        panic("int overflow")
    }

    return a + b
}
```

### Detecting an integer overflow during multiplication

```go
func MultiplyInt(a, b int) int {
    if a == 0 || b == 0 {
        return 0
    }

    result := a * b
    if a == 1 || b == 1 {
        return result
    }
    if a == math.MinInt || b == math.MinInt {
        panic("integer overflow")
    }
    if result / b != a {
        panic("integer overflow")
    }

    return result
}
```

## Not understanding floating points.

In Go, there are two floating-point types: float32 and float64. The concept of a floating point was invented to solve the major problem with integers: their inability to represent fractional values. To avoid bad surprises, we need to know that floating-point arithmetic is an approximation of real arithmetic.

```go
var n float32 = 1.0001
fmt.Println(n*n)
```

We may expect this code to print the result of 1.0001\*1.0001 = 1.00020001, right? However, running it on most x86 processors prints 1.0002, instead. How do we explain that? We need to understand the arithmetic of floating points first.

Note that there's and infinite number of read values between math.SmallestNonzeroFloat64 (the float64 minimum) and math.MaxFloat64 (the float64 maximum). Conversely, the float64 type has a finite number of bits: 64. Because making infinite values fit into a finite space isn't possible, we have to work with approximations. Hence, we may lose precision.

## Not understanding slice length and capacity

It's pretty common for Go developers to mix slice length and capacity or not understand them thoroughly. Assimililating these two concepts is essential for efficiently handling core operations such as slice initialization and adding elements with append, copying, or slicing. This misunderstanding can lead to using slices suboptimally or even to memory leaks.

In Go, a slice is backed by an array. That means the slice's data is stored contiguously in an array data structure. A slice also handles the logic of adding an element if the backing array is full or shrinking.

Internally, a slice holds a pointer to the backing array plus an length and a capacity. **The length is the number of elements the slice contains, whereas the capacity is the number of elements in the backing array.**

```go
s := make([]int, 3, 6)
```

The first argument, representing the length, is mandatory. However, the second argument representing the capacity is optional.

In this case, make creates an array of six elements (the capacity). But because the length was set to 3, Go initializes only the frist three elements. Also, because the slice is an []int type, the first three elements are initialized to the zeroed value of an int: 0. The remain elements are allocated but not yet used.

Accessing an element outside the length range is forbidden, even though it's already allocated in memory. For example, s[4] = 0 would lead to the following panic
