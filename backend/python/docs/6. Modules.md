# 6. Modules

## 6.1.1. Executing modules as scripts

When you run a Python module with

```py
python fibo.py <arguments>
```

the code in the module will be executed, just as if you imported it, but with the __name__ set to "__name__". That means that by adding this code at the end of your module:

```py
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
```

you can make the file usable as a script as well as an importable module, because the code that parses the command like only runs if the module is executed as the "main" file:

## 6.1.2. The Module Search Path

## 6.1.3. "Compiled" Python files

To speed up loading modules, Python caches the compiled version of each module in the __pycache__ directory under the name module.version.pyc, where the version encodes the format of the compiled file; it generally contains the Python version number.

## 6.4. Packages

Packages are a way of structuring Python's module namespace by using "dotted module names". For example, the module name A.B designates a submodule named B in a package name A. Just like the use of modules saves the authors of different modules from having to worry. 

When importing the package, Python searches through the directories on sys.path looking for the package subdirectory.

The __init__.py files are required to make Python treat directories containing the file as packages. This prevents directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. 
